<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stick Cricket 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }

        #score {
            font-size: 24px;
            font-weight: bold;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
        }

        #swingButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #swingButton:hover {
            background-color: #45a049;
        }

        /* Timing meter styles */
        #timingMeter {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }

        #timingZones {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .timing-zone {
            position: absolute;
            height: 100%;
            top: 0;
        }

        #perfectZone {
            left: 45%;
            width: 10%;
            background-color: gold;
            opacity: 0.7;
        }

        #goodZone {
            left: 35%;
            width: 30%;
            background-color: #44cc44;
            opacity: 0.7;
            z-index: -1;
        }

        #okayZone {
            left: 20%;
            width: 60%;
            background-color: #cccc44;
            opacity: 0.7;
            z-index: -2;
        }

        #timingIndicator {
            position: absolute;
            width: 4px;
            height: 24px;
            background-color: white;
            top: -2px;
            left: 0;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
            transition: left 0.1s ease-out;
            opacity: 0;
        }

        #timingResult {
            position: absolute;
            bottom: 105px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Game Over Screen Styles */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        #gameOverScreen.visible {
            opacity: 1;
            visibility: visible;
        }

        #gameOverTitle {
            font-size: 64px;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #000;
            font-weight: bold;
        }

        #gameOverScore {
            font-size: 36px;
            color: #ffffff;
            margin-bottom: 30px;
        }

        #restartButton {
            padding: 15px 40px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        #restartButton:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="ballCount">Balls: 0/6</div>
    </div>
    <div id="instructions">
        <p>Use mouse to move the bat left/right</p>
        <p>Click or press SPACE to swing the bat</p>
    </div>
    <button id="swingButton">SWING!</button>

    <!-- Timing Meter -->
    <div id="timingMeter">
        <div id="timingZones">
            <div class="timing-zone" id="okayZone"></div>
            <div class="timing-zone" id="goodZone"></div>
            <div class="timing-zone" id="perfectZone"></div>
            <div id="timingIndicator"></div>
        </div>
    </div>
    <div id="timingResult"></div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <div id="gameOverTitle">GAME OVER</div>
        <div id="gameOverScore">Your Score: 0</div>
        <button id="restartButton">PLAY AGAIN</button>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script>
        // Game variables
        let score = 0;
        let gameState = 'waiting'; // waiting, bowling, batting, resetting, gameover
        let swingTiming = 0; // 0-1, with 1 being perfect timing
        let hitFeedbackTimer = 0;
        let hitFeedbackText = '';
        let playerOut = false; // Track if player is bowled out
        let gameOverActive = false; // Track if game over screen is showing
        let ballCount = 0; // Track number of balls bowled in the over
        let timingMeterActive = false; // Track if timing meter is currently active
        let ballTypes = {
            'straight': 0.6,
            'swing': 0.1,
            'slow': 0.1,
            'fast': 0.2
        };

        // Three.js variables
        let scene, camera, renderer;
        let bat, ball, wickets;
        let fieldObj, pitchObj;
        let batPosition = 0; // -1 to 1 range for bat position

        // Physics variables
        let ballSpeed = 0.1;
        let ballDirection = { x: 0, y: 0, z: 1 }; // Moving toward batsman
        let gravity = 0.001;
        let bounceCoefficient = 0.7; // Ball bounce elasticity
        let swingFactor = 0.0005; // How much the ball swings
        let swingDirection = 1; // 1 or -1, determines swing direction
        let ballSpin = 0; // Amount of spin (affects bounce direction)
        let groundY = 0; // Y position of the ground
        let deliveryType = 'fast'; // 'fast', 'spin', 'swing'

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 1, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Create cricket field
            createField();

            // Create cricket bat
            createBat();

            // Create ball
            createBall();

            // Create wickets
            createWickets();

            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('keydown', onKeyDown);
            document.getElementById('swingButton').addEventListener('click', swingBat);

            // Add event listener for restart button
            document.getElementById('restartButton').addEventListener('click', restartGame);

            // Start animation loop
            animate();

            // Start game cycle
            setTimeout(startBowling, 2000);
        }

        function createField() {
            // Create simple cricket field
            const fieldGeometry = new THREE.CircleGeometry(20, 32);
            const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x7CFC00 }); // Lawn green
            fieldObj = new THREE.Mesh(fieldGeometry, fieldMaterial);
            fieldObj.rotation.x = -Math.PI / 2;
            fieldObj.position.y = -0.1;
            scene.add(fieldObj);

            // Create pitch
            const pitchGeometry = new THREE.PlaneGeometry(2, 10);
            const pitchMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C }); // Tan
            pitchObj = new THREE.Mesh(pitchGeometry, pitchMaterial);
            pitchObj.rotation.x = -Math.PI / 2;
            pitchObj.position.y = -0.09;
            scene.add(pitchObj);

            // Add wide marks (crease lines) at both ends
            addCreaseLines(-4, 3); // Bowler's end and batsman's end
        }

        function addCreaseLines(bowlerZ, batsmanZ) {
            const creaseMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

            // Bowler's end crease lines
            const bowlerCreaseGeometry = new THREE.BoxGeometry(2.2, 0.02, 0.05);
            const bowlerCrease = new THREE.Mesh(bowlerCreaseGeometry, creaseMaterial);
            bowlerCrease.position.set(0, -0.08, bowlerZ);
            scene.add(bowlerCrease);

            // Batsman's end crease lines
            const batsmanCreaseGeometry = new THREE.BoxGeometry(2.2, 0.02, 0.05);
            const batsmanCrease = new THREE.Mesh(batsmanCreaseGeometry, creaseMaterial);
            batsmanCrease.position.set(0, -0.08, batsmanZ);
            scene.add(batsmanCrease);

            // Add popping crease lines (perpendicular to pitch)
            const poppingCreaseGeometry = new THREE.BoxGeometry(0.05, 0.02, 0.5);

            // Batsman end popping creases
            for (let x = -1; x <= 1; x += 2) {
                const poppingCrease = new THREE.Mesh(poppingCreaseGeometry, creaseMaterial);
                poppingCrease.position.set(x, -0.08, batsmanZ - 0.25);
                scene.add(poppingCrease);
            }

            // Bowler end popping creases
            for (let x = -1; x <= 1; x += 2) {
                const poppingCrease = new THREE.Mesh(poppingCreaseGeometry, creaseMaterial);
                poppingCrease.position.set(x, -0.08, bowlerZ + 0.25);
                scene.add(poppingCrease);
            }
        }

        function createBat() {
            // Simple bat made of box geometry
            const batHandleGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            const batBladeGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.05);
            const batMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown

            const batHandle = new THREE.Mesh(batHandleGeometry, batMaterial);
            const batBlade = new THREE.Mesh(batBladeGeometry, batMaterial);

            batBlade.position.y = -0.6;

            bat = new THREE.Group();
            bat.add(batHandle);
            bat.add(batBlade);

            bat.position.set(0, 1, 2.5);
            bat.rotation.x = Math.PI / 6; // Slight tilt

            // Create a box for hit detection
            bat.hitBox = new THREE.Box3().setFromObject(bat);

            scene.add(bat);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xDC143C }); // Crimson
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, 1, -5); // Start far from batsman
            scene.add(ball);
        }

        function createWickets() {
            wickets = new THREE.Group();
            const wicketMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFAFA }); // Snow white

            // Create three stumps at batsman's end
            for (let i = -1; i <= 1; i++) {
                const stumpGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
                const stump = new THREE.Mesh(stumpGeometry, wicketMaterial);
                stump.position.set(i * 0.1, 0.35, 3);
                wickets.add(stump);

                // Add bails
                if (i < 1) {
                    const bailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 8);
                    const bail = new THREE.Mesh(bailGeometry, wicketMaterial);
                    bail.rotation.z = Math.PI / 2;
                    bail.position.set(i * 0.1 + 0.05, 0.72, 3);
                    wickets.add(bail);
                }
            }

            // Add stumps at bowler's end
            for (let i = -1; i <= 1; i++) {
                const stumpGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
                const stump = new THREE.Mesh(stumpGeometry, wicketMaterial);
                stump.position.set(i * 0.1, 0.35, -4);
                wickets.add(stump);

                // Add bails
                if (i < 1) {
                    const bailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 8);
                    const bail = new THREE.Mesh(bailGeometry, wicketMaterial);
                    bail.rotation.z = Math.PI / 2;
                    bail.position.set(i * 0.1 + 0.05, 0.72, -4);
                    wickets.add(bail);
                }
            }

            scene.add(wickets);
        }

        function startBowling() {
            if (gameState !== 'waiting') return;

            // Increment ball count
            ballCount++;

            // If we've reached 6 balls, end the over after this ball
            if (ballCount > 6) {
                // End of over - show game over
                showGameOverScreen();
                return;
            }

            // Update ball count display
            document.getElementById('ballCount').innerHTML = `Balls: ${ballCount}/6`;

            gameState = 'bowling';

            // Reset and prepare timing meter
            resetTimingMeter();
            timingMeterActive = true;

            // Choose ball type based on probability
            const randomVal = Math.random();
            let cumulativeProbability = 0;
            let selectedType = 'straight'; // Default

            for (const [type, probability] of Object.entries(ballTypes)) {
                cumulativeProbability += probability;
                if (randomVal <= cumulativeProbability) {
                    selectedType = type;
                    break;
                }
            }

            deliveryType = selectedType;

            // Reset ball position with slight variation
            ball.position.set(Math.random() * 0.4 - 0.2, 1, -5);

            // Set initial direction based on delivery type
            switch (deliveryType) {
                case 'fast':
                    ballSpeed = 0.15;
                    ballDirection = {
                        x: Math.random() * 0.01 - 0.005,
                        y: 0.01, // Slight upward trajectory
                        z: 0.13
                    };
                    gravity = 0.0015;
                    ballSpin = 0;
                    swingFactor = 0.0002;
                    break;

                case 'slow':
                    ballSpeed = 0.08;
                    ballDirection = {
                        x: Math.random() * 0.01 - 0.005,
                        y: 0.03, // Higher trajectory
                        z: 0.07
                    };
                    gravity = 0.0008;
                    ballSpin = (Math.random() > 0.5 ? 0.004 : -0.004);
                    swingFactor = 0.0001;
                    break;

                case 'swing':
                    ballSpeed = 0.12;
                    ballDirection = {
                        x: 0,
                        y: 0.015,
                        z: 0.11
                    };
                    gravity = 0.0012;
                    ballSpin = 0;
                    swingFactor = 0.001;
                    swingDirection = Math.random() > 0.5 ? 1 : -1; // Random swing direction
                    break;

                case 'straight':
                default:
                    ballSpeed = 0.12;
                    ballDirection = {
                        x: Math.random() * 0.005 - 0.0025, // Very slight random variation
                        y: 0.01,
                        z: 0.1
                    };
                    gravity = 0.001;
                    ballSpin = 0;
                    swingFactor = 0.0001; // Almost no swing
                    break;
            }

            // Update UI to show delivery type
            const scoreElement = document.getElementById('score');
            scoreElement.innerHTML = `Score: ${score} | ${deliveryType.toUpperCase()} ball`;
        }

        function swingBat() {
            if (gameState !== 'bowling') return;

            // Record the timing based on ball position
            // Perfect timing is when the ball is close to the bat (around z position 2.3-2.7)
            // Range is roughly -5 (bowler) to 3 (wickets)
            const ballDistanceFromIdeal = Math.abs(ball.position.z - 2.5);
            // Make timing more forgiving - wider window for good timing
            swingTiming = Math.max(0, 1 - (ballDistanceFromIdeal / 2.0));

            // Show timing result
            showTimingResult(swingTiming);

            // Debug output
            console.log(`Swing timing: ${swingTiming.toFixed(2)}, Ball Z: ${ball.position.z.toFixed(2)}`);

            // Animate bat swing with rotation around Y based on bat position (for different shot types)
            let swingAngle = -Math.PI / 3;
            const originalRotationX = bat.rotation.x;

            // Different shot types based on horizontal position
            let rotationY = 0;
            if (batPosition > 0.3) {
                // Square cut / pull shot
                rotationY = Math.PI / 6;
            } else if (batPosition < -0.3) {
                // Cover drive / off side shot
                rotationY = -Math.PI / 6;
            }

            bat.rotation.y = rotationY;

            const swingAnimation = setInterval(() => {
                bat.rotation.x = originalRotationX + swingAngle;
                swingAngle += 0.2;

                // Update hit box during swing
                bat.hitBox.setFromObject(bat);

                // Check if bat hits ball during swing animation
                checkBatBallCollision();

                if (swingAngle >= Math.PI / 2) {
                    clearInterval(swingAnimation);
                    // Return bat to original position
                    setTimeout(() => {
                        bat.rotation.x = originalRotationX;
                        bat.rotation.y = 0;
                        // Reset swing timing after swing is complete
                        swingTiming = 0;
                    }, 300);
                }
            }, 20);
        }

        function checkBatBallCollision() {
            // Create a sphere for the ball
            const ballRadius = 0.1;
            // Increase collision radius to make hitting easier
            const ballSphere = new THREE.Sphere(ball.position, ballRadius * 1.3);

            // Update bat hitbox
            bat.hitBox.setFromObject(bat);

            // Check if ball intersects with bat, with a wider window for collision
            // Only register the hit if the bat has been actively swung (swingTiming > 0)
            if (bat.hitBox.intersectsSphere(ballSphere) &&
                ball.position.z > 2.0 &&
                gameState === 'bowling' &&
                swingTiming > 0) { // Only count when bat is swung

                // Ball has been hit!
                console.log(`Ball hit! Ball position: x=${ball.position.x.toFixed(2)}, z=${ball.position.z.toFixed(2)}`);
                console.log(`Bat position: x=${bat.position.x.toFixed(2)}`);
                hitBall();
            }
        }

        function createRunPopup(runs, position) {
            // Simplified approach - use only DOM elements for run popups
            // Create a large text element in the center of the screen
            const runTextDiv = document.createElement('div');
            runTextDiv.id = `run-popup-${Date.now()}`; // Unique ID
            runTextDiv.textContent = runs.toString();
            runTextDiv.style.position = 'absolute';
            runTextDiv.style.top = '50%';
            runTextDiv.style.left = '50%';
            runTextDiv.style.transform = 'translate(-50%, -50%)';
            runTextDiv.style.fontSize = runs >= 4 ? '120px' : '96px';
            runTextDiv.style.fontWeight = 'bold';
            runTextDiv.style.color = '#00FF00'; // Bright green
            runTextDiv.style.textShadow = '0 0 10px #FFFFFF, 0 0 20px #FFFFFF';
            runTextDiv.style.fontFamily = 'Arial, sans-serif';
            runTextDiv.style.opacity = '0';
            runTextDiv.style.zIndex = '1000'; // Make sure it's on top
            runTextDiv.style.transition = 'all 1.5s ease-out';
            document.body.appendChild(runTextDiv);

            console.log(`Created run popup with ID ${runTextDiv.id} for ${runs} runs`);

            // Animate the run popup
            setTimeout(() => {
                runTextDiv.style.opacity = '1';
                runTextDiv.style.transform = 'translate(-50%, -200px) scale(1.5)';

                setTimeout(() => {
                    runTextDiv.style.opacity = '0';

                    // Remove the element after animation
                    setTimeout(() => {
                        if (document.body.contains(runTextDiv)) {
                            document.body.removeChild(runTextDiv);
                            console.log(`Removed run popup ${runTextDiv.id}`);
                        }
                    }, 1000);
                }, 1200);
            }, 100);
        }

        function hitBall() {
            gameState = 'batting';

            // Determine shot quality based on timing and position
            let shotQuality = swingTiming;

            // Factor in position accuracy (center of the bat is better)
            const positionAccuracy = 1 - Math.min(1, Math.abs(ball.position.x - bat.position.x) * 2);

            // Adjust the weighting to give more importance to timing
            shotQuality = shotQuality * 0.8 + positionAccuracy * 0.2;

            // Ensure minimum shot quality isn't too low when hitting - minimum 0.2 for any hit
            shotQuality = Math.max(0.2, shotQuality);

            console.log(`Shot quality: ${shotQuality.toFixed(2)}`);
            console.log(`Position accuracy: ${positionAccuracy.toFixed(2)}`);
            console.log(`Timing: ${swingTiming.toFixed(2)}`);

            // Use timing to determine runs and trajectory directly - less randomness
            // This ensures that the ball trajectory matches the runs scored
            const runQuality = swingTiming;
            let newRuns = 0;

            // Store original ball direction for smooth transition
            const originalDirection = {
                x: ballDirection.x,
                y: ballDirection.y,
                z: ballDirection.z
            };

            // Default target direction values - we'll modify these based on runs
            let targetDirectionX = bat.rotation.y * 3 + batPosition;
            let targetDirectionY = 0.01; // Base elevation
            let targetDirectionZ = -0.1; // Base reverse direction

            // More predictable run scoring based on timing
            if (runQuality > 0.9) {
                // Perfect timing - SIX!
                newRuns = 6;

                // High elevation, long distance
                targetDirectionY = 0.12;
                targetDirectionZ = -0.18;
            }
            else if (runQuality > 0.75) {
                // Great timing - FOUR!
                newRuns = 4;

                // Lower trajectory but fast horizontal movement
                targetDirectionY = 0.05;
                targetDirectionZ = -0.16;
            }
            else if (runQuality > 0.6) {
                // Good timing - THREE
                newRuns = 3;

                // Medium trajectory
                targetDirectionY = 0.04;
                targetDirectionZ = -0.12;
            }
            else if (runQuality > 0.45) {
                // Decent timing - TWO
                newRuns = 2;

                // Lower trajectory
                targetDirectionY = 0.03;
                targetDirectionZ = -0.08;
            }
            else if (runQuality > 0.3) {
                // Okay timing - ONE
                newRuns = 1;

                // Very low trajectory, short distance
                targetDirectionY = 0.02;
                targetDirectionZ = -0.05;
            }
            else {
                // Poor timing - DOT ball (no run)
                newRuns = 0;

                // Weakest hit
                targetDirectionY = 0.01;
                targetDirectionZ = -0.03;
            }

            // Apply bat position influence on direction
            const shotPower = 0.05 + (newRuns * 0.02); // More power based on runs

            // Set final target direction
            const targetDirection = {
                x: targetDirectionX,
                y: targetDirectionY,
                z: targetDirectionZ * (1 + shotPower) // Scale by power
            };

            console.log(`Runs: ${newRuns}, Ball direction: x=${targetDirection.x.toFixed(2)}, y=${targetDirection.y.toFixed(2)}, z=${targetDirection.z.toFixed(2)}`);

            // Setup smooth transition of ball direction over multiple frames
            let transitionProgress = 0;
            const transitionDuration = 10; // number of frames for smooth transition

            // Create transition function that will run each frame
            const smoothBallTransition = () => {
                if (transitionProgress < transitionDuration) {
                    // Calculate interpolation factor (0 to 1)
                    const t = transitionProgress / transitionDuration;
                    // Use easing function for smoother transition (cubic easing)
                    const easeFactor = t * t * (3 - 2 * t);

                    // Interpolate between original and target directions
                    ballDirection.x = originalDirection.x * (1 - easeFactor) + targetDirection.x * easeFactor;
                    ballDirection.y = originalDirection.y * (1 - easeFactor) + targetDirection.y * easeFactor;
                    ballDirection.z = originalDirection.z * (1 - easeFactor) + targetDirection.z * easeFactor;

                    transitionProgress++;
                    requestAnimationFrame(smoothBallTransition);
                } else {
                    // Transition complete, set final values
                    ballDirection.x = targetDirection.x;
                    ballDirection.y = targetDirection.y;
                    ballDirection.z = targetDirection.z;
                }
            };

            // Start the smooth transition
            smoothBallTransition();

            // Add visual feedback effect
            // Flash the ball color for good shots
            const originalColor = ball.material.color.getHex();
            if (newRuns >= 4) {
                ball.material.color.set(0xFFD700); // Gold for boundaries
            } else if (newRuns > 0) {
                ball.material.color.set(0x00FF00); // Green for other scoring shots
            } else {
                ball.material.color.set(0xAAAAAA); // Gray for dot balls
            }

            // Restore original color
            setTimeout(() => {
                if (ball && ball.material) ball.material.color.set(originalColor);
            }, 300);

            // Create animated run popup (even for 0 runs)
            createRunPopup(newRuns, ball.position.clone());

            // Update score - increment by the runs scored
            score += newRuns;

            console.log(`Updated total score: ${score}`);

            // Update score display immediately
            document.getElementById('score').innerHTML = `Score: ${score}`;

            // Remove the hit feedback text element if it exists
            const feedbackElement = document.getElementById('hitFeedback');
            if (feedbackElement) {
                document.body.removeChild(feedbackElement);
            }
        }

        function updateBallPosition() {
            // Don't update if game is over
            if (gameState === 'gameover') return;

            if (gameState !== 'bowling' && gameState !== 'batting') return;

            // Apply velocity
            ball.position.x += ballDirection.x;
            ball.position.y += ballDirection.y;
            ball.position.z += ballDirection.z;

            // ALWAYS apply gravity regardless of game state
            ballDirection.y -= gravity;

            // Check for bat-ball collision in bowling state
            if (gameState === 'bowling') {
                checkBatBallCollision();

                // Check for ball hitting stumps (only when bowling)
                if (ball.position.z >= 2.9 && ball.position.z <= 3.1 &&
                    ball.position.y <= 0.7 && ball.position.y >= 0 &&
                    Math.abs(ball.position.x) <= 0.15) {
                    // Ball has hit the stumps!
                    console.log("BOWLED OUT! Ball hit the stumps.");
                    playerOut = true;
                    gameState = 'bowled';

                    // Determine which stump was hit based on x position
                    let hitStumpIndex = 0; // Center stump by default
                    if (ball.position.x < -0.05) {
                        hitStumpIndex = -1; // Left stump
                    } else if (ball.position.x > 0.05) {
                        hitStumpIndex = 1; // Right stump
                    }

                    // Animate the stumps falling
                    animateStumpsFalling(hitStumpIndex);

                    // Show "BOWLED OUT!" message
                    showBowledOutMessage();
                }
            }

            // Apply swing (only when ball is in flight)
            if (ball.position.y > groundY + 0.1) {
                // Swing increases as the ball travels closer to the batsman
                const swingProgress = (ball.position.z + 5) / 7; // 0 to 1 as ball travels

                if (deliveryType === 'swing') {
                    // Late swing effect - increases as the ball gets closer to batsman
                    ballDirection.x += swingDirection * swingFactor * swingProgress;
                } else {
                    // Slight drift for other deliveries
                    ballDirection.x += swingDirection * swingFactor * 0.2;
                }
            }

            // Handle bounce when ball hits the ground
            if (ball.position.y <= groundY && ballDirection.y < 0) {
                // Ball has hit the ground
                // Bounce with energy loss
                ballDirection.y = -ballDirection.y * bounceCoefficient;

                // Reduce horizontal speed slightly due to friction
                ballDirection.x *= 0.95;
                ballDirection.z *= 0.95;

                // Add spin effect to bounce direction
                ballDirection.x += ballSpin;

                // Ensure ball doesn't go below ground
                ball.position.y = groundY;

                // Add visual bounce effect
                ball.scale.y = 0.8; // Squish the ball
                setTimeout(() => {
                    if (ball) ball.scale.y = 1; // Restore ball shape
                }, 50);
            }

            // Ball out of bounds or very slow - reset after delay
            if (Math.abs(ball.position.x) > 10 ||
                Math.abs(ball.position.z) > 10 ||
                (Math.abs(ballDirection.x) < 0.001 &&
                    Math.abs(ballDirection.y) < 0.001 &&
                    Math.abs(ballDirection.z) < 0.001 &&
                    gameState === 'batting')) {

                if (gameState !== 'resetting' && gameState !== 'bowled' && gameState !== 'gameover') {
                    gameState = 'resetting';
                    setTimeout(() => {
                        // Only auto-continue if not bowled out (game over)
                        if (!playerOut) {
                            gameState = 'waiting';
                            startBowling();
                        }
                    }, 2000);
                }
            }

            // Ensure ball always has some minimum velocity to prevent getting stuck
            const minVelocity = 0.001;
            if (Math.abs(ballDirection.x) < minVelocity &&
                Math.abs(ballDirection.z) < minVelocity &&
                Math.abs(ballDirection.y) < minVelocity &&
                gameState === 'batting') {

                // Apply a small downward force to ensure the ball falls
                ballDirection.y -= 0.005;
            }
        }

        function updateScoreUI() {
            const scoreElement = document.getElementById('score');

            if (scoreElement) {
                scoreElement.innerHTML = `Score: ${score}`;
                console.log(`Updated score display to: ${score}`);
            }
        }

        function onMouseMove(event) {
            // Calculate bat position from mouse
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            batPosition = Math.max(-1, Math.min(1, x));
            bat.position.x = batPosition * 0.5;
        }

        function onKeyDown(event) {
            if (event.code === 'Space') {
                swingBat();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateBallPosition();
            updateTimingMeter();

            // Update score UI every frame to ensure it's always current
            updateScoreUI();

            renderer.render(scene, camera);
        }

        // Add function to animate stumps falling when hit by the ball
        function animateStumpsFalling(hitStumpIndex) {
            // Get the stumps at batsman's end (the first three stumps in the wickets group)
            const stumps = [];
            let bailsToFall = [];

            // Collect the batsman's stumps and bails
            for (let i = 0; i < wickets.children.length; i++) {
                const child = wickets.children[i];
                // First 3 objects are the stumps at batsman's end
                if (i < 3) {
                    stumps.push(child);
                }
                // Next 2 objects are the bails at batsman's end
                else if (i < 5) {
                    bailsToFall.push(child);
                }
            }

            // Determine which stumps to animate based on the hit
            let stumpsToAnimate = [];
            if (hitStumpIndex === 0) {
                // Middle stump hit - affect middle and one random side
                stumpsToAnimate.push(stumps[1]);
                stumpsToAnimate.push(stumps[Math.random() > 0.5 ? 0 : 2]);
                bailsToFall = bailsToFall; // both bails fall
            } else if (hitStumpIndex === -1) {
                // Left stump hit
                stumpsToAnimate.push(stumps[0]);
                stumpsToAnimate.push(stumps[1]); // also affect middle stump
                bailsToFall = [bailsToFall[0]]; // only left bail falls
            } else {
                // Right stump hit
                stumpsToAnimate.push(stumps[2]);
                stumpsToAnimate.push(stumps[1]); // also affect middle stump
                bailsToFall = [bailsToFall[1]]; // only right bail falls
            }

            // Animate the stumps falling
            for (const stump of stumpsToAnimate) {
                // Random fall direction
                const fallAngleX = (Math.random() * 0.5) - 0.25;
                const fallAngleZ = -Math.random() * 0.5 - 0.1;

                // Animate the stump falling over time
                let fallProgress = 0;
                const fallInterval = setInterval(() => {
                    fallProgress += 0.1;

                    if (fallProgress <= 1) {
                        stump.rotation.x = fallAngleX * fallProgress;
                        stump.rotation.z = fallAngleZ * fallProgress;
                        // Stumps also slightly fall down
                        stump.position.y -= 0.02;
                    } else {
                        clearInterval(fallInterval);
                    }
                }, 50);
            }

            // Animate the bails falling
            for (const bail of bailsToFall) {
                // Random velocities for the bails flying off
                const vx = (Math.random() - 0.5) * 0.05;
                const vy = Math.random() * 0.05 + 0.03;
                const vz = -Math.random() * 0.05 - 0.02;

                // Animate the bail flying off
                let bailFallTime = 0;
                const bailInterval = setInterval(() => {
                    bailFallTime += 0.1;

                    if (bailFallTime <= 3) {
                        bail.position.x += vx;
                        bail.position.y += vy - (0.001 * bailFallTime * bailFallTime); // Parabolic arc
                        bail.position.z += vz;

                        // Rotate the bail as it flies
                        bail.rotation.x += 0.2;
                        bail.rotation.y += 0.1;

                        // Stop when the bail hits the ground
                        if (bail.position.y < 0.1) {
                            clearInterval(bailInterval);
                        }
                    } else {
                        clearInterval(bailInterval);
                    }
                }, 50);
            }
        }

        // Function to reset stumps to their original positions
        function resetStumps() {
            // Simply recreate the wickets
            scene.remove(wickets);
            createWickets();
        }

        // Function to show "BOWLED OUT!" message
        function showBowledOutMessage() {
            const messageElement = document.createElement('div');
            messageElement.id = 'bowled-message';
            messageElement.textContent = 'BOWLED OUT!';
            messageElement.style.position = 'absolute';
            messageElement.style.top = '40%';
            messageElement.style.left = '50%';
            messageElement.style.transform = 'translate(-50%, -50%)';
            messageElement.style.fontSize = '72px';
            messageElement.style.fontWeight = 'bold';
            messageElement.style.color = '#FF0000';
            messageElement.style.textShadow = '0 0 10px #000000, 0 0 20px #000000';
            messageElement.style.fontFamily = 'Arial, sans-serif';
            messageElement.style.opacity = '0';
            messageElement.style.zIndex = '1000';
            messageElement.style.transition = 'all 1s ease-out';
            document.body.appendChild(messageElement);

            // Animate the message
            setTimeout(() => {
                messageElement.style.opacity = '1';

                setTimeout(() => {
                    messageElement.style.opacity = '0';

                    // Remove the element after animation
                    setTimeout(() => {
                        if (document.body.contains(messageElement)) {
                            document.body.removeChild(messageElement);
                        }

                        // Show game over screen after bowled message fades
                        showGameOverScreen();
                    }, 1000);
                }, 2000);
            }, 100);
        }

        // Function to show the game over screen
        function showGameOverScreen() {
            // Update final score on game over screen with over details
            const reason = (ballCount >= 6) ? "Over Complete" : "Bowled Out!";
            document.getElementById('gameOverTitle').textContent = reason;
            document.getElementById('gameOverScore').textContent = `Final Score: ${score}`;

            // Show game over screen
            const gameOverScreen = document.getElementById('gameOverScreen');
            gameOverScreen.classList.add('visible');

            // Set game over state flags
            gameOverActive = true;
            gameState = 'gameover';
        }

        // Function to hide the game over screen
        function hideGameOverScreen() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            gameOverScreen.classList.remove('visible');
        }

        // Function to restart the game after game over
        function restartGame() {
            // Hide game over screen
            hideGameOverScreen();

            // Reset game state
            gameState = 'waiting';
            playerOut = false;
            gameOverActive = false;
            score = 0;
            ballCount = 0; // Reset ball count

            // Reset ball position
            ball.position.set(0, 1, -5);

            // Reset ball direction
            ballDirection = { x: 0, y: 0, z: 1 };

            // Restore stumps if they were knocked down
            resetStumps();

            // Update displays
            updateScoreUI();
            document.getElementById('ballCount').innerHTML = `Balls: 0/6`;

            // Start a new bowling delivery
            setTimeout(startBowling, 1000);
        }

        // Add timing meter functions
        function resetTimingMeter() {
            const indicator = document.getElementById('timingIndicator');
            const resultText = document.getElementById('timingResult');

            indicator.style.left = '0px';
            indicator.style.opacity = '1';
            resultText.style.opacity = '0';
            resultText.textContent = '';
        }

        function updateTimingMeter() {
            if (!timingMeterActive || gameState !== 'bowling') return;

            // Calculate position on meter based on ball distance
            // Ball travels from z=-5 to z=3, so normalize to 0-1 range
            const ballProgress = (ball.position.z + 5) / 8;
            const meterWidth = document.getElementById('timingMeter').offsetWidth;

            // Move indicator from left to right as ball approaches
            // Adjust the multiplier to make it move at a good speed
            const position = ballProgress * meterWidth;

            const indicator = document.getElementById('timingIndicator');
            indicator.style.left = `${position}px`;
        }

        function showTimingResult(timing) {
            const resultText = document.getElementById('timingResult');
            let result = '';
            let color = '';

            if (timing > 0.9) {
                result = 'PERFECT!';
                color = 'gold';
            } else if (timing > 0.75) {
                result = 'GREAT!';
                color = '#44cc44';
            } else if (timing > 0.5) {
                result = 'GOOD';
                color = '#88cc44';
            } else if (timing > 0.3) {
                result = 'OKAY';
                color = '#cccc44';
            } else {
                result = 'POOR';
                color = '#cc4444';
            }

            resultText.textContent = result;
            resultText.style.color = color;
            resultText.style.opacity = '1';

            // Freeze indicator
            const indicator = document.getElementById('timingIndicator');
            indicator.style.transition = 'none';

            // Hide after delay
            setTimeout(() => {
                timingMeterActive = false;
                indicator.style.opacity = '0';

                setTimeout(() => {
                    resultText.style.opacity = '0';
                }, 1000);
            }, 500);
        }

        // Start the game
        init();
    </script>
</body>

</html>