<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stick Cricket 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }

        #score {
            font-size: 24px;
            font-weight: bold;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
        }

        #swingButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #swingButton:hover {
            background-color: #45a049;
        }

        /* Timing meter styles */
        #timingMeter {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 12px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        #timingMeter:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.1), transparent);
            border-radius: 10px 10px 0 0;
            z-index: 4;
        }

        #timingZones {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 8px;
        }

        .timing-zone {
            position: absolute;
            height: 100%;
            top: 0;
            transition: all 0.3s ease;
        }

        /* Early zone - Red */
        #earlyZone {
            left: 0%;
            width: 40%;
            background: linear-gradient(to right, rgba(255, 50, 50, 0.8), rgba(255, 120, 50, 0.6));
            box-shadow: 0 0 8px #ff3232;
            z-index: 1;
        }

        /* Okay zone - Yellow (early side) */
        #okayEarlyZone {
            left: 40%;
            width: 10%;
            background: linear-gradient(to right, rgba(255, 120, 50, 0.6), rgba(255, 255, 50, 0.7));
            box-shadow: 0 0 5px #ffcc00;
            z-index: 2;
        }

        /* Perfect zone - Green */
        #perfectZone {
            left: 50%;
            width: 10%;
            background: linear-gradient(to right, rgba(50, 255, 50, 0.7), rgba(50, 255, 50, 0.9), rgba(50, 255, 50, 0.7));
            box-shadow: 0 0 8px #32ff32;
            z-index: 3;
            animation: perfectPulse 2s infinite alternate;
        }

        /* Okay zone - Yellow (late side) */
        #okayLateZone {
            left: 60%;
            width: 10%;
            background: linear-gradient(to right, rgba(255, 255, 50, 0.7), rgba(255, 120, 50, 0.6));
            box-shadow: 0 0 5px #ffcc00;
            z-index: 2;
        }

        /* Late zone - Red */
        #lateZone {
            left: 70%;
            width: 40%;
            background: linear-gradient(to right, rgba(255, 120, 50, 0.6), rgba(255, 50, 50, 0.8));
            box-shadow: 0 0 8px #ff3232;
            z-index: 1;
        }

        #timingIndicator {
            position: absolute;
            width: 3px;
            height: 18px;
            background-color: white;
            top: -3px;
            left: 0;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(255, 255, 255, 1), 0 0 12px rgba(255, 255, 255, 0.8);
            transition: left 0.1s ease-out;
            opacity: 0;
            z-index: 10;
        }

        #timingIndicator:after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            bottom: -2px;
            left: -2.5px;
            box-shadow: 0 0 8px white;
            animation: pulseGlow 1.5s infinite alternate;
        }

        /* Timing labels */
        .timing-label {
            position: absolute;
            bottom: 95px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            opacity: 0.7;
            transform: translateX(-50%);
        }

        #earlyLabel {
            left: 20%;
        }

        #perfectLabel {
            left: 55%;
            color: #32ff32;
        }

        #lateLabel {
            left: 85%;
        }

        #timingResult {
            position: absolute;
            bottom: 105px;
            left: 50%;
            transform: translateX(-50%) scale(0.9);
            font-size: 22px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.8), 2px 2px 3px rgba(0, 0, 0, 0.6);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            padding: 5px 15px;
            border-radius: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            letter-spacing: 1px;
        }

        /* Game Over Screen Styles */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        #gameOverScreen.visible {
            opacity: 1;
            visibility: visible;
        }

        #gameOverTitle {
            font-size: 64px;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #000;
            font-weight: bold;
        }

        #gameOverScore {
            font-size: 36px;
            color: #ffffff;
            margin-bottom: 30px;
        }

        #restartButton {
            padding: 15px 40px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        #restartButton:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }

        @keyframes perfectPulse {

            0%,
            100% {
                opacity: 0.7;
            }

            50% {
                opacity: 0.9;
            }
        }

        @keyframes pulseGlow {
            0% {
                opacity: 0.7;
                transform: scale(1);
            }

            100% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        @keyframes resultScale {
            0% {
                transform: translateX(-50%) scale(0.8);
            }

            30% {
                transform: translateX(-50%) scale(1.1);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="ballCount">Balls: 0/6</div>
    </div>
    <div id="instructions">
        <p>Use Mouse to move the bat left/right</p>
        <p>Press SPACE to swing the bat</p>
    </div>
    <button id="swingButton">SWING!</button>

    <!-- Timing Meter -->
    <div id="timingMeter">
        <div id="timingZones">
            <div class="timing-zone" id="earlyZone"></div>
            <div class="timing-zone" id="okayEarlyZone"></div>
            <div class="timing-zone" id="perfectZone"></div>
            <div class="timing-zone" id="okayLateZone"></div>
            <div class="timing-zone" id="lateZone"></div>
            <div id="timingIndicator"></div>
        </div>
    </div>
    <!-- <div class="timing-label" id="earlyLabel">EARLY</div>
    <div class="timing-label" id="perfectLabel">PERFECT</div>
    <div class="timing-label" id="lateLabel">LATE</div> -->
    <div id="timingResult"></div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <div id="gameOverTitle">GAME OVER</div>
        <div id="gameOverScore">Your Score: 0</div>
        <button id="restartButton">PLAY AGAIN</button>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script>
        // Game variables
        let score = 0;
        let gameState = 'waiting'; // waiting, bowling, batting, resetting, gameover
        let swingTiming = 0; // 0-1, with 1 being perfect timing
        let hitFeedbackTimer = 0;
        let hitFeedbackText = '';
        let playerOut = false; // Track if player is bowled out
        let gameOverActive = false; // Track if game over screen is showing
        let ballCount = 0; // Track number of balls bowled in the over
        let timingMeterActive = false; // Track if timing meter is currently active
        let ballTypes = {
            'straight': 0.6,
            'swing': 0.1,
            'slow': 0.1,
            'fast': 0.2
        };

        // Define pitch lengths and their probabilities
        let pitchLengths = {
            'yorker': 0.2,     // Pitches very close to batsman
            'full': 0.2,       // Pitches closer to batsman
            'good': 0.4,       // Pitches at optimal "good length"
            'short': 0.2       // Pitches closer to bowler, bounces higher
        };
        let currentPitchLength = 'good'; // Default pitch length

        // Ball trajectory visualization variables
        let trajectoryPoints = []; // Array to store trajectory points
        let trajectoryLine = null; // Line object for trajectory visualization
        let trajectoryMaxPoints = 100; // Maximum number of points to track
        let boundaryRadius = 18; // Radius of the boundary circle (increased from 14)
        let boundaryLine = null; // Reference to boundary line object
        let fourLine = null; // Reference to the 4-run line
        let sixLine = null; // Reference to the 6-run line
        let showTrajectory = true; // Whether to show trajectory
        let ballPositionMarkers = []; // Array to store ball position markers

        // Three.js variables
        let scene, camera, renderer;
        let bat, ball, wickets;
        let fieldObj, pitchObj;
        let batPosition = 0; // -1 to 1 range for bat position

        // Physics variables
        let ballSpeed = 0.1;
        let ballDirection = { x: 0, y: 0, z: 1 }; // Moving toward batsman
        let gravity = 0.001;
        let bounceCoefficient = 0.7; // Ball bounce elasticity
        let swingFactor = 0.0005; // How much the ball swings
        let swingDirection = 1; // 1 or -1, determines swing direction
        let ballSpin = 0; // Amount of spin (affects bounce direction)
        let groundY = 0; // Y position of the ground
        let deliveryType = 'fast'; // 'fast', 'spin', 'swing'

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();

            // Create dynamic sky with gradient
            const skyTexture = createSkyGradient();
            scene.background = skyTexture;

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 1, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Create cricket field
            createField();

            // Create cricket bat
            createBat();

            // Create ball
            createBall();

            // Create wickets
            createWickets();

            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('keydown', onKeyDown);
            document.getElementById('swingButton').addEventListener('click', swingBat);

            // Add event listener for restart button
            document.getElementById('restartButton').addEventListener('click', restartGame);

            // Start animation loop
            animate();

            // Start game cycle
            setTimeout(startBowling, 2000);
        }

        function createSkyGradient() {
            // Create a canvas for the sky gradient
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');

            // Create gradient
            const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1e90ff');  // Dodger blue (top)
            gradient.addColorStop(0.5, '#87ceeb'); // Sky blue (middle)
            gradient.addColorStop(1, '#e0f7fa');   // Very light blue (horizon)

            // Fill with gradient
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add some subtle cloud-like texture
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.7; // Keep clouds in upper part
                const radius = Math.random() * 50 + 20;
                const opacity = Math.random() * 0.15;

                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                context.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createField() {
            // Create enhanced cricket field with texture
            const fieldGeometry = new THREE.CircleGeometry(20, 64); // Increase segments for smoother circle

            // Create grass texture on canvas
            const grassTexture = createGrassTexture();

            const fieldMaterial = new THREE.MeshLambertMaterial({
                map: grassTexture,
                color: 0xaaffaa, // Light green tint
                side: THREE.DoubleSide,
                receiveShadow: true
            });

            fieldObj = new THREE.Mesh(fieldGeometry, fieldMaterial);
            fieldObj.rotation.x = -Math.PI / 2;
            fieldObj.position.y = -0.1;
            fieldObj.receiveShadow = true;
            scene.add(fieldObj);

            // Create pitch with improved texture
            const pitchGeometry = new THREE.PlaneGeometry(2, 10);

            // Create a canvas texture for the pitch
            const pitchTexture = createPitchTexture();

            const pitchMaterial = new THREE.MeshLambertMaterial({
                map: pitchTexture,
                side: THREE.DoubleSide,
                receiveShadow: true
            });

            pitchObj = new THREE.Mesh(pitchGeometry, pitchMaterial);
            pitchObj.rotation.x = -Math.PI / 2;
            pitchObj.position.y = -0.09;
            pitchObj.receiveShadow = true;
            scene.add(pitchObj);

            // Add boundary lines
            createBoundaryLines();

            // Add wide marks (crease lines) at both ends
            addCreaseLines(-4, 3); // Bowler's end and batsman's end
        }

        function createGrassTexture() {
            // Create a canvas for grass texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');

            // Base grass color
            context.fillStyle = '#4CAF50';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add horizontal grass cutting lines
            for (let i = 0; i < canvas.height; i += 20) {
                context.beginPath();
                context.moveTo(0, i);
                context.lineTo(canvas.width, i);
                context.strokeStyle = '#388E3C';
                context.lineWidth = 4;
                context.globalAlpha = 0.3;
                context.stroke();
            }

            // Add some random grass blades for texture
            context.globalAlpha = 0.4;
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const length = Math.random() * 5 + 3;
                const angle = Math.random() * Math.PI;

                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                context.strokeStyle = Math.random() > 0.5 ? '#81C784' : '#2E7D32';
                context.lineWidth = 1;
                context.stroke();
            }

            // Create circular gradient for the field
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 50,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
            gradient.addColorStop(0.8, 'rgba(0, 100, 0, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 50, 0, 0.2)');

            context.fillStyle = gradient;
            context.globalAlpha = 0.5;
            context.fillRect(0, 0, canvas.width, canvas.height);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(5, 5); // Repeat the texture

            return texture;
        }

        function createPitchTexture() {
            // Create a canvas for pitch texture
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 512;
            const context = canvas.getContext('2d');

            // Base pitch color (light tan)
            context.fillStyle = '#D2B48C';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add some grain texture
            context.globalAlpha = 0.3;
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2 + 1;

                context.fillStyle = Math.random() > 0.5 ? '#C19A6B' : '#E6D2B5';
                context.fillRect(x, y, size, size);
            }

            // Add wear marks in the middle of the pitch
            context.globalAlpha = 0.2;
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 10,
                canvas.width / 2, canvas.height / 2, 80
            );
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(1, 'transparent');

            context.fillStyle = gradient;
            context.fillRect(0, canvas.height / 3, canvas.width, canvas.height / 3);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createBoundaryLines() {
            // Create main boundary line with enhanced visuals - only one boundary line per cricket rules
            const boundaryGeometry = new THREE.RingGeometry(boundaryRadius - 0.15, boundaryRadius, 128);

            // Create a textured material for the boundary - traditional white rope
            const boundaryTexture = createBoundaryTexture();

            boundaryLine = new THREE.Mesh(boundaryGeometry, new THREE.MeshBasicMaterial({
                map: boundaryTexture,
                color: 0xFFFFFF,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            }));
            boundaryLine.rotation.x = -Math.PI / 2;
            boundaryLine.position.y = -0.08;
            scene.add(boundaryLine);

            // Create a glowing effect for the boundary
            const boundaryGlow = createGlowingBoundary(boundaryRadius);
            scene.add(boundaryGlow);

            // Add "BOUNDARY" label for clarity
            addBoundaryLabel();
        }

        function createBoundaryTexture() {
            // Create a canvas for the boundary texture
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 64;
            const context = canvas.getContext('2d');

            // Create a textured rope-like boundary
            const ropeSegments = 60;
            const segmentWidth = canvas.width / ropeSegments;

            // Add rope texture
            context.fillStyle = '#F5F5F5'; // White/off-white base
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add rope fiber textures
            context.globalAlpha = 0.4;
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const length = Math.random() * 20 + 5;
                const angle = Math.random() * 0.2 - 0.1 + Math.PI / 2; // Mostly horizontal fibers

                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                context.strokeStyle = Math.random() > 0.3 ? '#E5E5E5' : '#D5D5D5';
                context.lineWidth = Math.random() * 2 + 0.5;
                context.stroke();
            }

            // Add subtle rope coils
            for (let i = 0; i < ropeSegments; i++) {
                context.globalAlpha = 0.2;
                context.beginPath();
                context.moveTo(i * segmentWidth, 0);
                context.lineTo(i * segmentWidth, canvas.height);
                context.strokeStyle = '#CCCCCC';
                context.lineWidth = 1;
                context.stroke();

                // Add shadow/highlight to create 3D rope effect
                if (i % 2 === 0) {
                    context.globalAlpha = 0.1;
                    context.fillStyle = '#FFFFFF';
                    context.fillRect(i * segmentWidth, 0, segmentWidth / 2, canvas.height);

                    context.globalAlpha = 0.1;
                    context.fillStyle = '#AAAAAA';
                    context.fillRect(i * segmentWidth + segmentWidth / 2, 0, segmentWidth / 2, canvas.height);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.set(4, 1);

            return texture;
        }

        function createGlowingBoundary(radius) {
            // Create a slightly larger ring for the glow effect
            const glowGeometry = new THREE.RingGeometry(radius - 0.2, radius + 0.2, 128);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });

            const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
            glowRing.rotation.x = -Math.PI / 2;
            glowRing.position.y = -0.079;

            // Add animation for the glow
            const glowAnimation = () => {
                if (glowRing) {
                    glowRing.material.opacity = 0.1 + Math.sin(Date.now() * 0.002) * 0.1;
                }
                requestAnimationFrame(glowAnimation);
            };
            glowAnimation();

            return glowRing;
        }

        function addBoundaryLabel() {
            // Create a single boundary label in the appropriate place
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            // Create a gradient background
            const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0066CC');  // Royal blue
            gradient.addColorStop(1, '#003366');  // Dark blue

            // Draw a rounded rectangle
            context.fillStyle = gradient;
            drawRoundedRect(context, 0, 0, canvas.width, canvas.height, 12);
            context.fill();

            // Add stroke
            context.strokeStyle = 'white';
            context.lineWidth = 3;
            drawRoundedRect(context, 0, 0, canvas.width, canvas.height, 12);
            context.stroke();

            // Add text
            context.fillStyle = 'white';
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('BOUNDARY', canvas.width / 2, canvas.height / 2);

            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const boundaryLabel = new THREE.Sprite(material);
            boundaryLabel.position.set(0, 0.5, boundaryRadius + 1);
            boundaryLabel.scale.set(5, 1.5, 1);
            scene.add(boundaryLabel);
        }

        // Helper function to draw rounded rectangles for compatibility
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function highlightBoundary(type) {
            // Enhanced boundary highlighting with pulse effect
            if (type === "four") {
                // Create a pulsing circle at the boundary for four
                createBoundaryPulse(boundaryRadius, 0x00FF00); // Green for four

                // Add a "FOUR" text popup
                createRunTextPopup("FOUR", 0x00FF00);
            }
            else if (type === "six") {
                // Create a pulsing circle at the boundary for six
                createBoundaryPulse(boundaryRadius, 0xFFD700); // Gold for six

                // Add particle effect for six
                createBoundaryParticles();

                // Add a "SIX" text popup
                createRunTextPopup("SIX", 0xFFD700);
            }
        }

        function createRunTextPopup(text, color) {
            // Create a popup text effect
            const popup = document.createElement('div');
            popup.style.position = 'absolute';
            popup.style.left = '50%';
            popup.style.top = '30%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.color = '#' + color.toString(16).padStart(6, '0');
            popup.style.fontFamily = 'Arial, sans-serif';
            popup.style.fontSize = '80px';
            popup.style.fontWeight = 'bold';
            popup.style.textShadow = '2px 2px 5px rgba(0,0,0,0.5)';
            popup.style.opacity = '0';
            popup.style.transition = 'all 0.5s ease-in-out';
            popup.style.zIndex = '1000';
            popup.textContent = text;

            document.body.appendChild(popup);

            // Animate the text
            setTimeout(() => {
                popup.style.opacity = '1';
                popup.style.fontSize = '120px';

                setTimeout(() => {
                    popup.style.opacity = '0';
                    popup.style.fontSize = '150px';

                    setTimeout(() => {
                        if (document.body.contains(popup)) document.body.removeChild(popup);
                    }, 1000);
                }, 1500);
            }, 100);
        }

        function createBoundaryPulse(radius, color) {
            // Create a ring that pulses outward
            const pulseGeometry = new THREE.RingGeometry(radius - 0.05, radius + 0.05, 64);
            const pulseMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial);
            pulseRing.rotation.x = -Math.PI / 2;
            pulseRing.position.y = -0.05; // Slightly above field
            scene.add(pulseRing);

            // Animate the pulse
            let scale = 1;
            let opacity = 0.8;
            const pulseAnimation = setInterval(() => {
                scale += 0.04;
                opacity -= 0.02;

                pulseRing.scale.set(scale, scale, 1);
                pulseMaterial.opacity = opacity;

                if (opacity <= 0) {
                    clearInterval(pulseAnimation);
                    scene.remove(pulseRing);
                }
            }, 30);
        }

        function createBoundaryParticles() {
            // Create particles that spray up from the boundary
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xFFD700,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });

            // Create random positions around the boundary
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * boundaryRadius;
                const z = Math.sin(angle) * boundaryRadius;

                positions.push(x, 0, z);

                // Random velocity for animation
                velocities.push(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.1
                );
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Animate particles
            let frame = 0;
            const particleAnimation = setInterval(() => {
                frame++;
                const positions = particles.geometry.attributes.position.array;

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    // Update position based on velocity
                    positions[i3] += velocities[i3];
                    positions[i3 + 1] += velocities[i3 + 1];
                    positions[i3 + 2] += velocities[i3 + 2];

                    // Add gravity
                    velocities[i3 + 1] -= 0.01;
                }

                particles.geometry.attributes.position.needsUpdate = true;

                // Fade out particles
                particleMaterial.opacity = Math.max(0, 0.8 - frame * 0.02);

                if (frame > 40) {
                    clearInterval(particleAnimation);
                    scene.remove(particles);
                }
            }, 30);
        }

        function addCreaseLines(bowlerZ, batsmanZ) {
            const creaseMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

            // Bowler's end crease lines
            const bowlerCreaseGeometry = new THREE.BoxGeometry(2.2, 0.02, 0.05);
            const bowlerCrease = new THREE.Mesh(bowlerCreaseGeometry, creaseMaterial);
            bowlerCrease.position.set(0, -0.08, bowlerZ);
            scene.add(bowlerCrease);

            // Batsman's end crease lines
            const batsmanCreaseGeometry = new THREE.BoxGeometry(2.2, 0.02, 0.05);
            const batsmanCrease = new THREE.Mesh(batsmanCreaseGeometry, creaseMaterial);
            batsmanCrease.position.set(0, -0.08, batsmanZ);
            scene.add(batsmanCrease);

            // Add popping crease lines (perpendicular to pitch)
            const poppingCreaseGeometry = new THREE.BoxGeometry(0.05, 0.02, 0.5);

            // Batsman end popping creases
            for (let x = -1; x <= 1; x += 2) {
                const poppingCrease = new THREE.Mesh(poppingCreaseGeometry, creaseMaterial);
                poppingCrease.position.set(x, -0.08, batsmanZ - 0.25);
                scene.add(poppingCrease);
            }

            // Bowler end popping creases
            for (let x = -1; x <= 1; x += 2) {
                const poppingCrease = new THREE.Mesh(poppingCreaseGeometry, creaseMaterial);
                poppingCrease.position.set(x, -0.08, bowlerZ + 0.25);
                scene.add(poppingCrease);
            }
        }

        function createBat() {
            // Create a cricket bat with more realistic shape and textures
            const batGroup = new THREE.Group();

            // Handle (cylindrical)
            const handleGeometry = new THREE.CylinderGeometry(0.04, 0.05, 0.5, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513, // Brown
                shininess: 30,
                specular: 0x222222
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = 0;
            handle.castShadow = true;
            batGroup.add(handle);

            // Create bat blade with curved shape
            const bladeGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.05);

            // Create wood grain texture
            const bladeTexture = createWoodTexture();

            const bladeMaterial = new THREE.MeshPhongMaterial({
                map: bladeTexture,
                color: 0xD2B48C, // Tan
                shininess: 20,
                specular: 0x222222,
                bumpMap: bladeTexture,
                bumpScale: 0.02
            });

            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = -0.6;
            blade.castShadow = true;

            // Add a slight curve to the blade
            blade.geometry.vertices = addCurveToBlade(blade.geometry.vertices);

            batGroup.add(blade);

            // Add grip tape texture to handle
            const gripGeometry = new THREE.CylinderGeometry(0.041, 0.051, 0.48, 8);
            const gripMaterial = new THREE.MeshPhongMaterial({
                color: 0xeeeeee,
                shininess: 5,
                specular: 0x111111
            });

            // Add grip texture with canvas
            const gripTexture = createGripTexture();
            gripMaterial.map = gripTexture;

            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            grip.position.y = 0;
            batGroup.add(grip);

            // Add logo to bat
            const logoGeometry = new THREE.PlaneGeometry(0.15, 0.15);
            const logoMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0.8,
                color: 0xFFFFFF
            });

            const logo = new THREE.Mesh(logoGeometry, logoMaterial);
            logo.position.set(0, -0.4, 0.03);
            logo.rotation.x = Math.PI;
            batGroup.add(logo);

            // Finalize the bat
            bat = batGroup;
            bat.position.set(0, 1, 2.5);
            bat.rotation.x = Math.PI / 6; // Slight tilt

            // Create a box for hit detection
            bat.hitBox = new THREE.Box3().setFromObject(bat);

            scene.add(bat);
        }

        // Helper function that would normally reshape vertices
        // Since we can't directly modify the vertices in modern THREE.js, this is mocked
        function addCurveToBlade(vertices) {
            // This would normally modify the vertices to curve the blade
            // In modern THREE.js we would use BufferGeometry methods instead
            return vertices;
        }

        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 512;
            const context = canvas.getContext('2d');

            // Base wood color
            context.fillStyle = '#D2B48C'; // Tan
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add wood grain
            context.globalAlpha = 0.4;
            for (let i = 0; i < canvas.height; i += 2) {
                context.beginPath();
                context.moveTo(0, i);

                // Create wavy lines for wood grain
                for (let x = 0; x < canvas.width; x += 10) {
                    const y = i + Math.sin(x * 0.1) * 3;
                    context.lineTo(x, y);
                }

                context.strokeStyle = Math.random() > 0.5 ? '#8B4513' : '#A0522D';
                context.lineWidth = Math.random() * 2 + 0.5;
                context.stroke();
            }

            // Add some knots in the wood
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 10 + 5;

                const knot = context.createRadialGradient(x, y, 1, x, y, radius);
                knot.addColorStop(0, '#8B4513');
                knot.addColorStop(0.7, '#D2B48C');
                knot.addColorStop(1, 'transparent');

                context.fillStyle = knot;
                context.globalAlpha = 0.7;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createGripTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const context = canvas.getContext('2d');

            // Base grip color
            context.fillStyle = '#EEEEEE';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add grip texture lines
            for (let i = 0; i < canvas.height; i += 5) {
                context.beginPath();
                context.moveTo(0, i);
                context.lineTo(canvas.width, i);
                context.strokeStyle = '#CCCCCC';
                context.lineWidth = 2;
                context.stroke();
            }

            // Add diagonal grip patterns
            context.lineWidth = 1;
            for (let i = -canvas.width; i < canvas.width * 2; i += 10) {
                context.beginPath();
                context.moveTo(i, 0);
                context.lineTo(i + canvas.height, canvas.height);
                context.strokeStyle = '#AAAAAA';
                context.stroke();

                context.beginPath();
                context.moveTo(i + 5, 0);
                context.lineTo(i + 5 + canvas.height, canvas.height);
                context.strokeStyle = '#DDDDDD';
                context.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2);

            return texture;
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const ballMaterial = new THREE.MeshLambertMaterial({
                color: 0xDC143C, // Crimson
                // Add phong material properties for better lighting
                shininess: 30,
                specular: 0x333333
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, 1, -5); // Start far from batsman
            ball.castShadow = true;  // Allow ball to cast shadows

            // Initialize ball properties
            ball.runsCounted = false;
            ball.boundaryCrossed = false;
            ball.predictedRuns = undefined;
            ball.intendedDistance = undefined;
            ball.reachedTargetDistance = false;
            ball.stuckCheckTimer = null;
            ball.lowestY = 1; // Track the lowest y-position to detect ground contact
            ball.originalScale = { x: 1, y: 1, z: 1 }; // Store original scale
            ball.bounceCount = 0; // Track number of bounces

            scene.add(ball);

            // Initialize trajectory visualization
            initTrajectoryVisualization();
        }

        function initTrajectoryVisualization() {
            // Create material for trajectory line
            const trajectoryMaterial = new THREE.LineBasicMaterial({
                color: 0xFF4500,  // OrangeRed
                linewidth: 1.5,
                opacity: 0.7,
                transparent: true
            });

            // Create empty geometry for the trajectory line
            const trajectoryGeometry = new THREE.BufferGeometry();

            // Create line with initial empty geometry
            trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
            scene.add(trajectoryLine);

            // Clear trajectory points array
            trajectoryPoints = [];
        }

        function updateTrajectoryVisualization() {
            if (!showTrajectory || gameState === 'waiting' || gameState === 'gameover') {
                // Don't show trajectory in these states
                if (trajectoryLine) trajectoryLine.visible = false;
                return;
            }

            // Make trajectory visible
            if (trajectoryLine) trajectoryLine.visible = true;

            // Add current ball position to trajectory points
            if (ball) {
                trajectoryPoints.push(ball.position.clone());

                // Limit the number of points to prevent performance issues
                if (trajectoryPoints.length > trajectoryMaxPoints) {
                    trajectoryPoints.shift(); // Remove oldest point
                }

                // Update trajectory line geometry
                updateTrajectoryLine();
            }
        }

        function updateTrajectoryLine() {
            if (trajectoryPoints.length < 2 || !trajectoryLine) return; // Need at least 2 points for a line

            // Convert trajectory points to flat array for BufferGeometry
            const positions = new Float32Array(trajectoryPoints.length * 3);

            for (let i = 0; i < trajectoryPoints.length; i++) {
                positions[i * 3] = trajectoryPoints[i].x;
                positions[i * 3 + 1] = trajectoryPoints[i].y;
                positions[i * 3 + 2] = trajectoryPoints[i].z;
            }

            // Update the line geometry
            trajectoryLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trajectoryLine.geometry.attributes.position.needsUpdate = true;
        }

        function clearTrajectory() {
            // Clear trajectory points
            trajectoryPoints = [];

            // Update trajectory line with empty points
            if (trajectoryLine) {
                const positions = new Float32Array(0);
                trajectoryLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trajectoryLine.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createWickets() {
            wickets = new THREE.Group();
            const wicketMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFAFA }); // Snow white

            // Create three stumps at batsman's end
            for (let i = -1; i <= 1; i++) {
                const stumpGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
                const stump = new THREE.Mesh(stumpGeometry, wicketMaterial);
                stump.position.set(i * 0.1, 0.35, 3);
                wickets.add(stump);

                // Add bails
                if (i < 1) {
                    const bailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 8);
                    const bail = new THREE.Mesh(bailGeometry, wicketMaterial);
                    bail.rotation.z = Math.PI / 2;
                    bail.position.set(i * 0.1 + 0.05, 0.72, 3);
                    wickets.add(bail);
                }
            }

            // Add stumps at bowler's end
            for (let i = -1; i <= 1; i++) {
                const stumpGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
                const stump = new THREE.Mesh(stumpGeometry, wicketMaterial);
                stump.position.set(i * 0.1, 0.35, -4);
                wickets.add(stump);

                // Add bails
                if (i < 1) {
                    const bailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 8);
                    const bail = new THREE.Mesh(bailGeometry, wicketMaterial);
                    bail.rotation.z = Math.PI / 2;
                    bail.position.set(i * 0.1 + 0.05, 0.72, -4);
                    wickets.add(bail);
                }
            }

            scene.add(wickets);
        }

        function startBowling() {
            if (gameState !== 'waiting') return;

            // Increment ball count
            ballCount++;

            // If we've reached 6 balls, end the over after this ball
            if (ballCount > 6) {
                // End of over - show game over
                showGameOverScreen();
                return;
            }

            // Update ball count display
            document.getElementById('ballCount').innerHTML = `Balls: ${ballCount}/6`;

            gameState = 'bowling';

            // Reset and prepare timing meter
            resetTimingMeter();
            timingMeterActive = true;

            // Clear any previous trajectory
            clearTrajectory();

            // Reset the ball's boundaryCrossed flag
            if (ball) {
                // Reset ball position to bowler's end
                ball.position.set(0, 1, -5);

                // Reset ball direction toward batsman
                ballDirection = { x: 0, y: 0, z: 1 };

                // Reset all ball state flags
                ball.boundaryCrossed = false;
                ball.runsCounted = false;
                ball.predictedRuns = undefined;
                ball.intendedDistance = undefined;
                ball.reachedTargetDistance = false;
                ball.lowestY = 1; // Reset lowest Y position
                ball.bounceCount = 0; // Reset bounce count

                // Ensure ball is at proper scale
                ball.scale.set(1, 1, 1);

                // Clear any stuck check timer
                if (ball.stuckCheckTimer) {
                    clearTimeout(ball.stuckCheckTimer);
                    ball.stuckCheckTimer = null;
                }
            }

            // Choose ball type based on probability
            const randomVal = Math.random();
            let cumulativeProbability = 0;
            let selectedType = 'straight'; // Default

            for (const [type, probability] of Object.entries(ballTypes)) {
                cumulativeProbability += probability;
                if (randomVal <= cumulativeProbability) {
                    selectedType = type;
                    break;
                }
            }

            deliveryType = selectedType;

            // Choose pitch length based on probability
            const randomPitchVal = Math.random();
            cumulativeProbability = 0;

            for (const [length, probability] of Object.entries(pitchLengths)) {
                cumulativeProbability += probability;
                if (randomPitchVal <= cumulativeProbability) {
                    currentPitchLength = length;
                    break;
                }
            }

            // Initialize variables based on selected delivery type
            switch (deliveryType) {
                case 'straight':
                    gravity = 0.01; // Further increased gravity
                    ballSpeed = 0.12;
                    ballSpin = 0;
                    swingFactor = 0;
                    break;
                case 'swing':
                    gravity = 0.01; // Further increased gravity
                    ballSpeed = 0.11;
                    ballSpin = 0;
                    swingFactor = 0.001;
                    swingDirection = Math.random() > 0.5 ? 1 : -1;
                    break;
                case 'slow':
                    gravity = 0.01; // Further increased gravity
                    ballSpeed = 0.09;
                    ballSpin = (Math.random() > 0.5 ? 0.002 : -0.002);
                    swingFactor = 0.0003;
                    break;
                case 'fast':
                    gravity = 0.01; // Further increased gravity
                    ballSpeed = 0.14;
                    ballSpin = 0;
                    swingFactor = 0.0002;
                    break;
            }
            // Set initial trajectory based on pitch length
            let initialY = 0;
            switch (currentPitchLength) {
                case 'yorker':
                    initialY = 0.0003; // Further lower trajectory for yorker
                    break;
                case 'full':
                    initialY = 0.0015; // Further adjusted trajectory for full length
                    break;
                case 'good':
                    initialY = 0.003; // Further adjusted trajectory for good length
                    break;
                case 'short':
                    initialY = 0.007; // Further adjusted trajectory for short length
                    break;
            }

            // Add slight variations to make bowling less predictable
            const xVariation = (Math.random() * 0.01) - 0.005; // Small lateral variation

            // Set the ball direction with the calculated values
            ballDirection = {
                x: xVariation,
                y: initialY,
                z: 1.0  // Forward momentum towards batsman
            };

            // Update UI to show delivery type
            const scoreElement = document.getElementById('score');
            scoreElement.innerHTML = `Score: ${score} | ${deliveryType.toUpperCase()} ${currentPitchLength} ball`;
        }

        function swingBat() {
            if (gameState !== 'bowling') return;

            // Record the timing based on ball position
            // Perfect timing is when the ball is close to the bat (around z position 2.3-2.7)
            // Range is roughly -5 (bowler) to 3 (wickets)
            const ballDistanceFromIdeal = Math.abs(ball.position.z - 2.5);
            // Make timing more forgiving - wider window for good timing
            swingTiming = Math.max(0, 1 - (ballDistanceFromIdeal / 2.0));

            // Show timing result
            showTimingResult(swingTiming);

            // Debug output
            console.log(`Swing timing: ${swingTiming.toFixed(2)}, Ball Z: ${ball.position.z.toFixed(2)}`);

            // Animate bat swing with rotation around Y based on bat position (for different shot types)
            let swingAngle = -Math.PI / 3;
            const originalRotationX = bat.rotation.x;

            // Different shot types based on horizontal position
            let rotationY = 0;
            if (batPosition > 0.3) {
                // Square cut / pull shot
                rotationY = Math.PI / 6;
            } else if (batPosition < -0.3) {
                // Cover drive / off side shot
                rotationY = -Math.PI / 6;
            }

            bat.rotation.y = rotationY;

            const swingAnimation = setInterval(() => {
                bat.rotation.x = originalRotationX + swingAngle;
                swingAngle += 0.2;

                // Update hit box during swing animation
                bat.hitBox.setFromObject(bat);

                // Check if bat hits ball during swing animation
                checkBatBallCollision();

                if (swingAngle >= Math.PI / 2) {
                    clearInterval(swingAnimation);
                    // Return bat to original position
                    setTimeout(() => {
                        bat.rotation.x = originalRotationX;
                        bat.rotation.y = 0;
                        // Reset swing timing after swing is complete
                        swingTiming = 0;
                    }, 300);
                }
            }, 20);
        }

        function checkBatBallCollision() {
            // Create a sphere for the ball
            const ballRadius = 0.05;
            // Increase collision radius to make hitting easier
            const ballSphere = new THREE.Sphere(ball.position, ballRadius * 1.3);

            // Update bat hitbox
            bat.hitBox.setFromObject(bat);

            // Check if ball intersects with bat, with a wider window for collision
            // Only register the hit if the bat has been actively swung (swingTiming > 0)
            if (bat.hitBox.intersectsSphere(ballSphere) &&
                ball.position.z > 2.0 &&
                gameState === 'bowling' &&
                swingTiming > 0) { // Only count when bat is swung

                // Ball has been hit!
                console.log(`Ball hit! Ball position: x=${ball.position.x.toFixed(2)}, z=${ball.position.z.toFixed(2)}`);
                console.log(`Bat position: x=${bat.position.x.toFixed(2)}`);
                hitBall();
            }
        }

        function hitBall() {
            gameState = 'batting';

            // Clear trajectory at hit time to start fresh
            clearTrajectory();

            // Determine shot quality based on timing and position
            let shotQuality = swingTiming;

            // Factor in position accuracy (center of the bat is better)
            const positionAccuracy = 1 - Math.min(1, Math.abs(ball.position.x - bat.position.x) * 2);

            // Adjust the weighting to give more importance to timing
            shotQuality = shotQuality * 0.7 + positionAccuracy * 0.3;

            // Ensure minimum shot quality isn't too low when hitting - minimum 0.2 for any hit
            shotQuality = Math.max(0.2, shotQuality);

            console.log(`Shot quality: ${shotQuality.toFixed(2)}`);
            console.log(`Position accuracy: ${positionAccuracy.toFixed(2)}`);
            console.log(`Timing: ${swingTiming.toFixed(2)}`);

            // Use timing to determine runs directly
            const runQuality = swingTiming;
            let newRuns = 0;

            // Store original ball direction for smooth transition
            const originalDirection = {
                x: ballDirection.x,
                y: ballDirection.y,
                z: ballDirection.z
            };

            // Default target direction values - we'll modify these based on runs
            let targetDirectionX = bat.rotation.y * 3 + batPosition;
            let targetDirectionY = 0.03; // Base elevation (increased from 0.01)
            let targetDirectionZ = -0.2; // Base reverse direction (increased from -0.1)

            // Calculate maximum distances for each run score
            // Updated distances as per requirements:
            // 1 run: 10-20 meters
            // 2 runs: 20-30 meters
            // 3 runs: 30-50 meters
            // 4/6 runs: go to boundary
            const maxDistances = {
                0: 8,   // Dot ball - very short distance (increased from 5)
                1: 15,  // Single - 10-20 meter range (using middle value)
                2: 25,  // Double - 20-30 meter range (using middle value)
                3: 40,  // Triple - 30-50 meter range (using middle value)
                4: 14,  // Four - reaches ground boundary (increased from 10)
                6: 20   // Six - clears boundary in the air (increased from 15)
            };

            // Set runs based on timing quality
            if (runQuality > 0.9) {
                // Perfect timing - SIX!
                newRuns = 6;

                // High elevation, long distance
                targetDirectionY = 0.2;  // Increased from 0.14
                targetDirectionZ = -0.25; // Increased from -0.14
            }
            else if (runQuality > 0.75) {
                // Great timing - FOUR!
                newRuns = 4;

                // Lower trajectory but fast horizontal movement
                targetDirectionY = 0.1;  // Increased from 0.06
                targetDirectionZ = -0.22; // Increased from -0.13
            }
            else if (runQuality > 0.6) {
                // Good timing - THREE
                newRuns = 3;

                // Medium trajectory, won't reach boundary
                targetDirectionY = 0.08; // Increased from 0.045
                targetDirectionZ = -0.18; // Increased from -0.09
            }
            else if (runQuality > 0.45) {
                // Decent timing - TWO
                newRuns = 2;

                // Lower trajectory, shorter distance
                targetDirectionY = 0.06; // Increased from 0.03
                targetDirectionZ = -0.14; // Increased from -0.065
            }
            else if (runQuality > 0.3) {
                // Okay timing - ONE
                newRuns = 1;

                // Very low trajectory, short distance
                targetDirectionY = 0.04; // Increased from 0.02
                targetDirectionZ = -0.1;  // Increased from -0.04
            }
            else {
                // Poor timing - DOT ball (no run)
                newRuns = 0;

                // Weakest hit
                targetDirectionY = 0.02; // Increased from 0.01
                targetDirectionZ = -0.05; // Increased from -0.02
            }

            // Calculate shot power based on run value and intended distance
            const intendedDistance = maxDistances[newRuns];
            const shotPower = intendedDistance / 10; // Scale power by intended distance ratio (changed from 14 to 10)

            // Apply bat position influence on direction
            targetDirectionX *= (1 + shotPower * 0.8); // Horizontal adjustment based on power (increased from 0.5 to 0.8)

            // Set final target direction with scaled components
            const targetDirection = {
                x: targetDirectionX * (0.8 + shotPower * 0.6), // More power means more horizontal control (increased from 0.4 to 0.6)
                y: targetDirectionY * (0.9 + shotPower * 0.5), // More power means higher trajectory (increased from 0.3 to 0.5)
                z: targetDirectionZ * (0.8 + shotPower * 0.7)  // More power means more forward distance (increased from 0.5 to 0.7)
            };

            console.log(`Runs: ${newRuns}, Intended distance: ${intendedDistance.toFixed(1)}, Shot power: ${shotPower.toFixed(2)}`);
            console.log(`Ball direction: x=${targetDirection.x.toFixed(2)}, y=${targetDirection.y.toFixed(2)}, z=${targetDirection.z.toFixed(2)}`);

            // Setup smooth transition of ball direction over multiple frames
            let transitionProgress = 0;
            const transitionDuration = 10; // number of frames for smooth transition

            // Create transition function that will run each frame
            const smoothBallTransition = () => {
                if (transitionProgress < transitionDuration) {
                    // Calculate interpolation factor (0 to 1)
                    const t = transitionProgress / transitionDuration;
                    // Use easing function for smoother transition (cubic easing)
                    const easeFactor = t * t * (3 - 2 * t);

                    // Interpolate between original and target directions
                    ballDirection.x = originalDirection.x * (1 - easeFactor) + targetDirection.x * easeFactor;
                    ballDirection.y = originalDirection.y * (1 - easeFactor) + targetDirection.y * easeFactor;
                    ballDirection.z = originalDirection.z * (1 - easeFactor) + targetDirection.z * easeFactor;

                    transitionProgress++;
                    requestAnimationFrame(smoothBallTransition);
                } else {
                    // Transition complete, set final values
                    ballDirection.x = targetDirection.x;
                    ballDirection.y = targetDirection.y;
                    ballDirection.z = targetDirection.z;
                }
            };

            // Start the smooth transition
            smoothBallTransition();

            // Increase ball speed based on shot quality and run value
            // Higher quality shots and higher run values get more speed
            const baseSpeed = 0.15; // Base speed for any hit (increased from default 0.1)
            const qualityBonus = shotQuality * 0.1; // Up to 0.1 bonus for perfect shots
            const runBonus = (newRuns / 6) * 0.1; // Up to 0.1 bonus for maximum runs

            // Set the new ball speed
            ballSpeed = baseSpeed + qualityBonus + runBonus;
            console.log(`Ball speed: ${ballSpeed.toFixed(2)}`);

            // Add visual feedback effect
            // Flash the ball color for good shots
            const originalColor = ball.material.color.getHex();
            if (newRuns >= 4) {
                ball.material.color.set(0xFFD700); // Gold for boundaries
            } else if (newRuns > 0) {
                ball.material.color.set(0x00FF00); // Green for other scoring shots
            } else {
                ball.material.color.set(0xAAAAAA); // Gray for dot balls
            }

            // Restore original color
            setTimeout(() => {
                if (ball && ball.material) ball.material.color.set(originalColor);
            }, 300);

            // Store the predicted runs on the ball object for boundary detection
            ball.predictedRuns = newRuns;
            ball.intendedDistance = intendedDistance;

            // Display an initial run popup that will be smaller and more subtle
            // (Only for feedback - score won't be updated until ball stops or crosses boundary)
            // createRunPopup(newRuns, ball.position.clone(), true);
        }

        function createRunPopup(runs, position, isInitial = false) {
            // Simplified approach - use only DOM elements for run popups
            // Create a large text element in the center of the screen
            const runTextDiv = document.createElement('div');
            const popupId = `run-popup-${Date.now()}`; // Unique ID
            runTextDiv.id = popupId;
            runTextDiv.textContent = runs.toString();
            runTextDiv.style.position = 'absolute';
            runTextDiv.style.top = '50%';
            runTextDiv.style.left = '50%';
            runTextDiv.style.transform = 'translate(-50%, -50%)';
            runTextDiv.style.fontSize = runs >= 4 ? '120px' : '96px';
            runTextDiv.style.fontWeight = 'bold';

            // Different colors based on run count
            if (runs >= 6) {
                runTextDiv.style.color = '#FFD700'; // Gold for sixes
            } else if (runs >= 4) {
                runTextDiv.style.color = '#00FF00'; // Green for fours
            } else if (runs > 0) {
                runTextDiv.style.color = '#FFFFFF'; // White for other runs
            } else {
                runTextDiv.style.color = '#AAAAAA'; // Gray for dot balls
            }

            runTextDiv.style.textShadow = '0 0 10px #000000, 0 0 20px #000000';
            runTextDiv.style.fontFamily = 'Arial, sans-serif';
            runTextDiv.style.opacity = '0';
            runTextDiv.style.zIndex = '1000'; // Make sure it's on top
            runTextDiv.style.transition = 'all 1.5s ease-out';
            document.body.appendChild(runTextDiv);

            console.log(`Created run popup with ID ${runTextDiv.id} for ${runs} runs`);

            // If this is the initial popup, make it smaller and more subtle
            if (isInitial) {
                runTextDiv.style.fontSize = runs >= 4 ? '80px' : '64px';
                runTextDiv.style.opacity = '0.7';
            }

            // Animate the run popup
            setTimeout(() => {
                runTextDiv.style.opacity = isInitial ? '0.7' : '1';
                runTextDiv.style.transform = 'translate(-50%, -200px) scale(1.5)';

                setTimeout(() => {
                    runTextDiv.style.opacity = '0';

                    // Remove the element after animation
                    setTimeout(() => {
                        if (document.body.contains(runTextDiv)) {
                            document.body.removeChild(runTextDiv);
                            console.log(`Removed run popup ${runTextDiv.id}`);
                        }
                    }, 1000);
                }, isInitial ? 800 : 1200); // Shorter display time for initial popup
            }, 100);

            // Store the popup ID on the ball for potential updates
            if (ball) ball.currentPopupId = popupId;

            return popupId;
        }

        function updateBallPosition() {
            if (gameState === 'bowling' || gameState === 'batting') {
                // Update ball position based on direction and speed
                ball.position.x += ballDirection.x * ballSpeed;
                ball.position.y += ballDirection.y * ballSpeed;
                ball.position.z += ballDirection.z * ballSpeed;

                // Apply gravity to Y direction
                ballDirection.y -= gravity;

                // Track lowest Y position to determine if ball has touched the ground
                if (ball.position.y < ball.lowestY) {
                    ball.lowestY = ball.position.y;
                }

                // Handle bounce when ball hits the ground
                if (ball.position.y <= groundY && ballDirection.y < 0) {
                    // Only allow one bounce
                    if (ball.bounceCount < 1) {
                        // Ball has hit the ground
                        // Make sure the ball doesn't go below ground
                        ball.position.y = groundY;

                        // Bounce with energy loss
                        ballDirection.y = -ballDirection.y * bounceCoefficient;

                        // Apply lateral spin effect if any
                        ballDirection.x += ballSpin;

                        // Add bounce visualization - squish the ball
                        ball.scale.set(1.1, 0.8, 1.1); // Flatten Y, expand X and Z slightly

                        // Increment bounce counter
                        ball.bounceCount++;

                        // Return to normal shape after squish
                        setTimeout(() => {
                            if (ball) {
                                // Smoothly transition back to original shape
                                const restoreScale = () => {
                                    ball.scale.x = THREE.MathUtils.lerp(ball.scale.x, 1, 0.3);
                                    ball.scale.y = THREE.MathUtils.lerp(ball.scale.y, 1, 0.3);
                                    ball.scale.z = THREE.MathUtils.lerp(ball.scale.z, 1, 0.3);

                                    if (Math.abs(ball.scale.y - 1) > 0.01) {
                                        requestAnimationFrame(restoreScale);
                                    } else {
                                        ball.scale.set(1, 1, 1); // Ensure perfect shape at end
                                    }
                                };
                                requestAnimationFrame(restoreScale);
                            }
                        }, 60);
                    } else {
                        // After first bounce, just keep the ball above ground but don't bounce
                        ball.position.y = groundY;
                    }
                }

                // Check for bat-ball collision in bowling state
                if (gameState === 'bowling') {
                    checkBatBallCollision();

                    // Check for ball hitting stumps
                    if (ball.position.z >= 2.9 && ball.position.z <= 3.1 &&
                        ball.position.y <= 0.7 && ball.position.y >= 0 &&
                        Math.abs(ball.position.x) <= 0.15) {
                        // Ball has hit the stumps!
                        console.log("BOWLED OUT! Ball hit the stumps.");
                        playerOut = true;
                        gameState = 'bowled';

                        // Determine which stump was hit based on x position
                        let hitStumpIndex = 0; // Center stump by default
                        if (ball.position.x < -0.05) {
                            hitStumpIndex = -1; // Left stump
                        } else if (ball.position.x > 0.05) {
                            hitStumpIndex = 1; // Right stump
                        }

                        // Animate the stumps falling
                        animateStumpsFalling(hitStumpIndex);

                        // Show "BOWLED OUT!" message
                        showBowledOutMessage();
                    }
                }

                // Update trajectory visualization
                updateTrajectoryVisualization();
            }
        }

        function updateBallPhysics() {
            // Check if the ball has crossed the boundary
            if (gameState === 'batting' && ball.position.y < 1 && !ball.boundaryCrossed) {
                const distanceFromCenter = Math.sqrt(ball.position.x * ball.position.x + ball.position.z * ball.position.z);

                if (distanceFromCenter >= boundaryRadius) {
                    ball.boundaryCrossed = true;

                    // Determine if it's a four or a six based on whether the ball has bounced
                    // Check if ball has touched the ground (if y position has been below a certain level)
                    const hasTouchedGround = ball.lowestY < 0.1; // If ball has gone below this height, it touched the ground

                    if (hasTouchedGround) {
                        // It's a four - the ball touched the ground before crossing boundary
                        updateRunsForBoundary(4);
                        highlightBoundary("four");
                        console.log("FOUR! Ball crossed boundary after touching ground.");

                        // Reset the ball immediately after showing the run
                        resetBall();
                    } else {
                        // It's a six - ball crossed boundary without touching ground
                        updateRunsForBoundary(6);
                        highlightBoundary("six");
                        console.log("SIX! Ball crossed boundary without touching ground.");

                        // Reset the ball immediately after showing the run
                        resetBall();
                    }
                }
            }

            // For non-boundary runs, make the ball stop more realistically
            if (gameState === 'batting' && !ball.boundaryCrossed) {
                // Apply more friction to slow the ball gradually when it's near the ground
                if (ball.position.y < 0.5) {
                    ballDirection.x *= 0.985; // Reduced friction (changed from 0.97)
                    ballDirection.z *= 0.985; // Reduced friction (changed from 0.97)
                }

                // If the ball is moving quite slowly and near the ground, stop it entirely
                if (Math.abs(ballDirection.x) < 0.005 && // Reduced threshold (changed from 0.01)
                    Math.abs(ballDirection.z) < 0.005 && // Reduced threshold (changed from 0.01)
                    ball.position.y < 0.2) {

                    // Ball has stopped - calculate runs based on distance
                    const distanceFromCenter = Math.sqrt(ball.position.x * ball.position.x + ball.position.z * ball.position.z);

                    // Only calculate runs if not already counted
                    if (!ball.runsCounted) {
                        let calculatedRuns = 0;

                        // Scale runs based on distance - keep ball from reaching boundary on 1/2/3 runs
                        if (distanceFromCenter < boundaryRadius * 0.3) {
                            calculatedRuns = 1;
                        } else if (distanceFromCenter < boundaryRadius * 0.5) {
                            calculatedRuns = 2;
                        } else if (distanceFromCenter < boundaryRadius * 0.7) {
                            calculatedRuns = 3;
                        }

                        if (calculatedRuns > 0) {
                            updateRunsForBoundary(calculatedRuns);
                            console.log(`${calculatedRuns} RUNS! Ball stopped at distance: ${distanceFromCenter.toFixed(2)}`);

                            // Reset the ball immediately after showing the run
                            resetBall();
                        }
                    }

                    // Further decay motion to ensure the ball stops completely
                    ballDirection.x = 0;
                    ballDirection.y = 0;
                    ballDirection.z = 0;
                }
            }

            // Check if ball has gone too far or is effectively stopped
            if ((Math.abs(ball.position.x) > 30 ||
                Math.abs(ball.position.z) > 30 ||
                (Math.abs(ballDirection.x) < 0.001 &&
                    Math.abs(ballDirection.z) < 0.001 &&
                    Math.abs(ballDirection.y) < 0.001 &&
                    ball.position.y < 0.2)) &&
                gameState !== 'resetting' &&
                gameState !== 'bowled' &&
                gameState !== 'gameover') {

                resetBall();
            }
        }

        function resetBall() {
            gameState = 'resetting';

            // Clear any stuck check timer
            if (ball.stuckCheckTimer) {
                clearTimeout(ball.stuckCheckTimer);
                ball.stuckCheckTimer = null;
            }

            // Update score if not already done
            if (!ball.runsCounted && ball.predictedRuns !== undefined) {
                updateRunsForBoundary(ball.predictedRuns);
                ball.runsCounted = true;
            }

            // Clear trajectory
            clearTrajectory();

            // Check if a boundary was scored (4 or 6)
            const wasBoundary = ball.boundaryCrossed;

            // Reset the ball immediately instead of with a delay
            // Use a much shorter delay of 500ms to reset more quickly after runs are shown
            setTimeout(() => {
                if (ball) {
                    // Reset ball properties
                    ball.boundaryCrossed = false;
                    ball.runsCounted = false;
                    ball.predictedRuns = undefined;
                    ball.intendedDistance = undefined;
                    ball.reachedTargetDistance = false;
                    ball.lowestY = 1;
                    ball.bounceCount = 0;

                    // Reset ball scale to ensure it's not squished
                    ball.scale.set(1, 1, 1);
                }

                // Continue game if not out
                if (!playerOut) {
                    gameState = 'waiting';

                    // Add extra delay for boundaries before starting the next ball
                    if (wasBoundary) {
                        // For boundaries, add a longer delay (3 seconds total)
                        setTimeout(startBowling, 3000);
                    } else {
                        // For non-boundaries, start bowling immediately
                        startBowling();
                    }
                }
            }, 1000); // Base delay of 1 second
        }

        function updateRunsForBoundary(finalRuns) {
            // If the score has already been updated for this ball, don't do it again
            if (ball && ball.runsCounted) {
                console.log("Runs already counted for this ball, skipping duplicate update");
                return;
            }

            // Update the score
            score += finalRuns;

            // Mark as counted to prevent duplicate scoring
            if (ball) ball.runsCounted = true;

            // Update score display
            document.getElementById('score').innerHTML = `Score: ${score}`;

            // For boundary runs, only show the boundary text
            if (finalRuns === 4 || finalRuns === 6) {
                showBoundaryText(finalRuns);
            }
            // For non-boundary runs, only show the run popup
            else {
                createRunPopup(finalRuns, ball.position.clone(), false);
            }

            console.log(`Updated total score to ${score} with ${finalRuns} runs`);
        }

        function showBoundaryText(runs) {
            const boundaryText = document.createElement('div');
            boundaryText.id = 'boundary-text';
            boundaryText.textContent = runs === 4 ? 'FOUR!' : 'SIX!';
            boundaryText.style.position = 'absolute';
            boundaryText.style.top = '40%';
            boundaryText.style.left = '50%';
            boundaryText.style.transform = 'translate(-50%, -50%) scale(0.5)';
            boundaryText.style.fontSize = '150px';
            boundaryText.style.fontWeight = 'bold';
            boundaryText.style.color = runs === 4 ? '#00FF00' : '#FFD700';
            boundaryText.style.textShadow = '0 0 20px rgba(0,0,0,0.8), 0 0 40px rgba(0,0,0,0.5)';
            boundaryText.style.fontFamily = 'Arial, sans-serif';
            boundaryText.style.opacity = '0';
            boundaryText.style.zIndex = '2000';
            boundaryText.style.transition = 'all 1s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            boundaryText.style.pointerEvents = 'none';
            boundaryText.style.whiteSpace = 'nowrap';
            document.body.appendChild(boundaryText);

            // Add background glow effect
            const glowEffect = document.createElement('div');
            glowEffect.style.position = 'absolute';
            glowEffect.style.top = '0';
            glowEffect.style.left = '0';
            glowEffect.style.right = '0';
            glowEffect.style.bottom = '0';
            glowEffect.style.backgroundColor = runs === 4 ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 215, 0, 0.1)';
            glowEffect.style.zIndex = '1999';
            glowEffect.style.opacity = '0';
            glowEffect.style.transition = 'all 0.8s ease';
            glowEffect.style.pointerEvents = 'none';
            document.body.appendChild(glowEffect);

            // Animate the boundary text with a slight delay
            setTimeout(() => {
                boundaryText.style.opacity = '1';
                boundaryText.style.transform = 'translate(-50%, -50%) scale(1.2)';
                glowEffect.style.opacity = '1';

                // Sound effect for boundary
                if (typeof Audio !== 'undefined') {
                    const sound = new Audio();
                    sound.src = runs === 4 ? 'four_sound.mp3' : 'six_sound.mp3';
                    sound.volume = 0.4;
                    sound.play().catch(e => console.log("Sound couldn't play:", e));
                }

                setTimeout(() => {
                    boundaryText.style.opacity = '0';
                    boundaryText.style.transform = 'translate(-50%, -50%) scale(1.5)';
                    glowEffect.style.opacity = '0';

                    // Remove elements after animation
                    setTimeout(() => {
                        if (document.body.contains(boundaryText)) document.body.removeChild(boundaryText);
                        if (document.body.contains(glowEffect)) document.body.removeChild(glowEffect);
                    }, 1000);
                }, 2000);
            }, 200);
        }

        function highlightBoundary(type) {
            // Enhanced boundary highlighting with pulse effect
            if (type === "four") {
                // Create a pulsing circle at the boundary for four
                createBoundaryPulse(boundaryRadius, 0x00FF00); // Green for four

                // Add a "FOUR" text popup
                createRunTextPopup("FOUR", 0x00FF00);
            }
            else if (type === "six") {
                // Create a pulsing circle at the boundary for six
                createBoundaryPulse(boundaryRadius, 0xFFD700); // Gold for six

                // Add particle effect for six
                createBoundaryParticles();

                // Add a "SIX" text popup
                createRunTextPopup("SIX", 0xFFD700);
            }
        }

        function createRunTextPopup(text, color) {
            // Create a popup text effect
            const popup = document.createElement('div');
            popup.style.position = 'absolute';
            popup.style.left = '50%';
            popup.style.top = '30%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.color = '#' + color.toString(16).padStart(6, '0');
            popup.style.fontFamily = 'Arial, sans-serif';
            popup.style.fontSize = '80px';
            popup.style.fontWeight = 'bold';
            popup.style.textShadow = '2px 2px 5px rgba(0,0,0,0.5)';
            popup.style.opacity = '0';
            popup.style.transition = 'all 0.5s ease-in-out';
            popup.style.zIndex = '1000';
            popup.textContent = text;

            document.body.appendChild(popup);

            // Animate the text
            setTimeout(() => {
                popup.style.opacity = '1';
                popup.style.fontSize = '120px';

                setTimeout(() => {
                    popup.style.opacity = '0';
                    popup.style.fontSize = '150px';

                    setTimeout(() => {
                        if (document.body.contains(popup)) document.body.removeChild(popup);
                    }, 1000);
                }, 1500);
            }, 100);
        }

        function updateScoreUI() {
            const scoreElement = document.getElementById('score');

            if (scoreElement) {
                scoreElement.innerHTML = `Score: ${score}`;
                console.log(`Updated score display to: ${score}`);
            }
        }

        function onMouseMove(event) {
            // Calculate bat position from mouse
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            batPosition = Math.max(-1, Math.min(1, x));
            bat.position.x = batPosition * 0.5;
        }

        function onKeyDown(event) {
            if (event.code === 'Space') {
                swingBat();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateBallPosition();
            updateBallPhysics();
            updateTimingMeter();

            // Update score UI every frame to ensure it's always current
            updateScoreUI();

            renderer.render(scene, camera);
        }

        // Add function to animate stumps falling when hit by the ball
        function animateStumpsFalling(hitStumpIndex) {
            // Get the stumps at batsman's end (the first three stumps in the wickets group)
            const stumps = [];
            let bailsToFall = [];

            // Collect the batsman's stumps and bails
            for (let i = 0; i < wickets.children.length; i++) {
                const child = wickets.children[i];
                // First 3 objects are the stumps at batsman's end
                if (i < 3) {
                    stumps.push(child);
                }
                // Next 2 objects are the bails at batsman's end
                else if (i < 5) {
                    bailsToFall.push(child);
                }
            }

            // Determine which stumps to animate based on the hit
            let stumpsToAnimate = [];
            if (hitStumpIndex === 0) {
                // Middle stump hit - affect middle and one random side
                stumpsToAnimate.push(stumps[1]);
                stumpsToAnimate.push(stumps[Math.random() > 0.5 ? 0 : 2]);
                bailsToFall = bailsToFall; // both bails fall
            } else if (hitStumpIndex === -1) {
                // Left stump hit
                stumpsToAnimate.push(stumps[0]);
                stumpsToAnimate.push(stumps[1]); // also affect middle stump
                bailsToFall = [bailsToFall[0]]; // only left bail falls
            } else {
                // Right stump hit
                stumpsToAnimate.push(stumps[2]);
                stumpsToAnimate.push(stumps[1]); // also affect middle stump
                bailsToFall = [bailsToFall[1]]; // only right bail falls
            }

            // Animate the stumps falling
            for (const stump of stumpsToAnimate) {
                // Random fall direction
                const fallAngleX = (Math.random() * 0.5) - 0.25;
                const fallAngleZ = -Math.random() * 0.5 - 0.1;

                // Animate the stump falling over time
                let fallProgress = 0;
                const fallInterval = setInterval(() => {
                    fallProgress += 0.1;

                    if (fallProgress <= 1) {
                        stump.rotation.x = fallAngleX * fallProgress;
                        stump.rotation.z = fallAngleZ * fallProgress;
                        // Stumps also slightly fall down
                        stump.position.y -= 0.02;
                    } else {
                        clearInterval(fallInterval);
                    }
                }, 50);
            }

            // Animate the bails falling
            for (const bail of bailsToFall) {
                // Random velocities for the bails flying off
                const vx = (Math.random() - 0.5) * 0.05;
                const vy = Math.random() * 0.05 + 0.03;
                const vz = -Math.random() * 0.05 - 0.02;

                // Animate the bail flying off
                let bailFallTime = 0;
                const bailInterval = setInterval(() => {
                    bailFallTime += 0.1;

                    if (bailFallTime <= 3) {
                        bail.position.x += vx;
                        bail.position.y += vy - (0.001 * bailFallTime * bailFallTime); // Parabolic arc
                        bail.position.z += vz;

                        // Rotate the bail as it flies
                        bail.rotation.x += 0.2;
                        bail.rotation.y += 0.1;

                        // Stop when the bail hits the ground
                        if (bail.position.y < 0.1) {
                            clearInterval(bailInterval);
                        }
                    } else {
                        clearInterval(bailInterval);
                    }
                }, 50);
            }
        }

        // Function to reset stumps to their original positions
        function resetStumps() {
            // Simply recreate the wickets
            scene.remove(wickets);
            createWickets();
        }

        // Function to show "BOWLED OUT!" message
        function showBowledOutMessage() {
            const messageElement = document.createElement('div');
            messageElement.id = 'bowled-message';
            messageElement.textContent = 'BOWLED OUT!';
            messageElement.style.position = 'absolute';
            messageElement.style.top = '40%';
            messageElement.style.left = '50%';
            messageElement.style.transform = 'translate(-50%, -50%)';
            messageElement.style.fontSize = '72px';
            messageElement.style.fontWeight = 'bold';
            messageElement.style.color = '#FF0000';
            messageElement.style.textShadow = '0 0 10px #000000, 0 0 20px #000000';
            messageElement.style.fontFamily = 'Arial, sans-serif';
            messageElement.style.opacity = '0';
            messageElement.style.zIndex = '1000';
            messageElement.style.transition = 'all 1s ease-out';
            document.body.appendChild(messageElement);

            // Animate the message
            setTimeout(() => {
                messageElement.style.opacity = '1';

                setTimeout(() => {
                    messageElement.style.opacity = '0';

                    // Remove the element after animation
                    setTimeout(() => {
                        if (document.body.contains(messageElement)) {
                            document.body.removeChild(messageElement);
                        }

                        // Show game over screen after bowled message fades
                        showGameOverScreen();
                    }, 1000);
                }, 2000);
            }, 100);
        }

        // Function to show the game over screen
        function showGameOverScreen() {
            // Update final score on game over screen with over details
            const reason = "Game Over";
            document.getElementById('gameOverTitle').textContent = reason;
            document.getElementById('gameOverScore').textContent = `Final Score: ${score}`;

            // Show game over screen
            const gameOverScreen = document.getElementById('gameOverScreen');
            gameOverScreen.classList.add('visible');

            // Set game over state flags
            gameOverActive = true;
            gameState = 'gameover';
        }

        // Function to hide the game over screen
        function hideGameOverScreen() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            gameOverScreen.classList.remove('visible');
        }

        // Function to restart the game after game over
        function restartGame() {
            // Hide game over screen
            hideGameOverScreen();

            // Reset game state
            gameState = 'waiting';
            playerOut = false;
            gameOverActive = false;
            score = 0;
            ballCount = 0; // Reset ball count

            // Reset ball position
            ball.position.set(0, 1, -5);

            // Reset ball direction
            ballDirection = { x: 0, y: 0, z: 1 };

            // Clear trajectory
            clearTrajectory();

            // Restore stumps if they were knocked down
            resetStumps();

            // Update displays
            updateScoreUI();
            document.getElementById('ballCount').innerHTML = `Balls: 0/6`;

            // Start a new bowling delivery
            setTimeout(startBowling, 1000);
        }

        // Add timing meter functions
        function resetTimingMeter() {
            const indicator = document.getElementById('timingIndicator');
            const resultText = document.getElementById('timingResult');
            const earlyZone = document.getElementById('earlyZone');
            const okayEarlyZone = document.getElementById('okayEarlyZone');
            const perfectZone = document.getElementById('perfectZone');
            const okayLateZone = document.getElementById('okayLateZone');
            const lateZone = document.getElementById('lateZone');
            const timingMeter = document.getElementById('timingMeter');

            // Reset indicator with animations
            indicator.style.left = '0px';
            indicator.style.opacity = '1';
            indicator.style.transition = 'left 0.1s ease-out';
            indicator.style.boxShadow = '0 0 8px rgba(255, 255, 255, 1), 0 0 12px rgba(255, 255, 255, 0.8)';
            indicator.style.backgroundColor = 'white';

            // Reset result
            resultText.style.opacity = '0';
            resultText.textContent = '';
            resultText.style.transform = 'translateX(-50%) scale(0.9)';
            resultText.style.boxShadow = 'none';
            resultText.style.animation = 'none';

            // Reset zones
            earlyZone.style.opacity = '0.7';
            okayEarlyZone.style.opacity = '0.7';
            perfectZone.style.opacity = '0.7';
            okayLateZone.style.opacity = '0.7';
            lateZone.style.opacity = '0.7';

            earlyZone.style.boxShadow = '0 0 8px #ff3232';
            okayEarlyZone.style.boxShadow = '0 0 5px #ffcc00';
            perfectZone.style.boxShadow = '0 0 8px #32ff32';
            okayLateZone.style.boxShadow = '0 0 5px #ffcc00';
            lateZone.style.boxShadow = '0 0 8px #ff3232';

            // Reset meter
            timingMeter.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(0, 0, 0, 0.5)';
            timingMeter.style.transform = 'translateX(-50%)';

            // Set timing meter as active
            timingMeterActive = true;
        }

        function updateTimingMeter() {
            if (!timingMeterActive || gameState !== 'bowling') return;

            // Calculate position on meter based on ball distance
            // Ball travels from z=-5 to z=3, so normalize to 0-1 range
            // We want to get a value that's 0.5 (50% - center) when the ball is at the ideal position
            // Ideal position is around z=2.5
            const ballPositionZ = ball.position.z;
            const ballRangeMin = -5; // Starting position
            const ballRangeMax = 3;  // Wickets position
            const idealPosition = 2.5; // The perfect hitting position
            const totalRange = ballRangeMax - ballRangeMin;

            // Calculate a normalized position that will be 0.5 when the ball is at the ideal position
            // This ensures the indicator is in the middle "green" zone when timing is perfect
            let normalizedPosition;

            if (ballPositionZ < idealPosition) {
                // Ball is still approaching - map from 0 to 0.5
                const distanceFromStart = ballPositionZ - ballRangeMin;
                const approachProgress = distanceFromStart / (idealPosition - ballRangeMin);
                normalizedPosition = approachProgress * 0.5; // Map to 0-0.5 range (early)
            } else {
                // Ball has passed ideal position - map from 0.5 to 1
                const distanceFromIdeal = ballPositionZ - idealPosition;
                const departureProgress = distanceFromIdeal / (ballRangeMax - idealPosition);
                normalizedPosition = 0.5 + (departureProgress * 0.5); // Map to 0.5-1 range (late)
            }

            // Clamp the value between 0 and 1
            normalizedPosition = Math.max(0, Math.min(1, normalizedPosition));

            const meterWidth = document.getElementById('timingMeter').offsetWidth;
            const position = normalizedPosition * meterWidth;

            const indicator = document.getElementById('timingIndicator');
            indicator.style.left = `${position}px`;
        }

        function showTimingResult(timing) {
            const resultText = document.getElementById('timingResult');
            let result = '';
            let color = '';
            let scale = 1.0;

            // Get the ball position to determine if it's early or late
            const ballZ = ball.position.z;
            const idealZ = 2.5; // Perfect timing position
            const isTooEarly = ballZ < idealZ - 0.3;
            const isTooLate = ballZ > idealZ + 0.3;

            // Determine timing quality
            if (timing > 0.9) {
                result = 'PERFECT!';
                color = '#32ff32'; // Green
                scale = 1.3;
            } else if (timing > 0.75) {
                result = isTooEarly ? 'GOOD (EARLY)' : isTooLate ? 'GOOD (LATE)' : 'GOOD!';
                color = '#ffff32'; // Yellow
                scale = 1.2;
            } else if (timing > 0.5) {
                result = isTooEarly ? 'EARLY' : isTooLate ? 'LATE' : 'OKAY';
                color = '#ffcc32'; // Orange-yellow
                scale = 1.1;
            } else if (timing > 0.3) {
                result = isTooEarly ? 'TOO EARLY' : 'TOO LATE';
                color = '#ff7732'; // Orange
                scale = 1.0;
            } else {
                result = isTooEarly ? 'VERY EARLY!' : 'VERY LATE!';
                color = '#ff3232'; // Red
                scale = 0.9;
            }

            // Apply animations for a more dynamic appearance
            resultText.style.animation = 'none';
            // Trigger reflow to restart animation
            void resultText.offsetWidth;
            resultText.style.animation = 'resultScale 0.4s forwards';

            resultText.textContent = result;
            resultText.style.color = color;
            resultText.style.opacity = '1';
            resultText.style.transform = `translateX(-50%) scale(${scale})`;
            resultText.style.boxShadow = `0 0 10px ${color}, 0 0 15px rgba(${getColorRGB(color)}, 0.5)`;
            resultText.style.textShadow = `0 0 8px ${color}, 2px 2px 3px rgba(0,0,0,0.6)`;

            // Highlight the appropriate zone
            const earlyZone = document.getElementById('earlyZone');
            const okayEarlyZone = document.getElementById('okayEarlyZone');
            const perfectZone = document.getElementById('perfectZone');
            const okayLateZone = document.getElementById('okayLateZone');
            const lateZone = document.getElementById('lateZone');
            const timingMeter = document.getElementById('timingMeter');

            // Reset all zones
            earlyZone.style.opacity = '0.7';
            okayEarlyZone.style.opacity = '0.7';
            perfectZone.style.opacity = '0.7';
            okayLateZone.style.opacity = '0.7';
            lateZone.style.opacity = '0.7';

            // Add a dramatic effect to meter based on timing
            if (timing > 0.9) {
                timingMeter.style.boxShadow = `0 0 15px ${color}, inset 0 0 5px rgba(0, 0, 0, 0.5)`;
                perfectZone.style.opacity = '1';
                perfectZone.style.boxShadow = '0 0 15px #32ff32, 0 0 30px rgba(50, 255, 50, 0.5)';
                // Add subtle scale effect
                timingMeter.style.transform = 'translateX(-50%) scale(1.05)';
            } else if (timing > 0.75) {
                timingMeter.style.boxShadow = `0 0 10px ${color}, inset 0 0 5px rgba(0, 0, 0, 0.5)`;
                if (isTooEarly) {
                    okayEarlyZone.style.opacity = '1';
                    okayEarlyZone.style.boxShadow = '0 0 15px #ffcc00, 0 0 20px rgba(255, 204, 0, 0.3)';
                } else if (isTooLate) {
                    okayLateZone.style.opacity = '1';
                    okayLateZone.style.boxShadow = '0 0 15px #ffcc00, 0 0 20px rgba(255, 204, 0, 0.3)';
                } else {
                    perfectZone.style.opacity = '1';
                    perfectZone.style.boxShadow = '0 0 15px #ffff32, 0 0 20px rgba(255, 255, 50, 0.3)';
                }
                timingMeter.style.transform = 'translateX(-50%) scale(1.02)';
            } else if (timing > 0.3) {
                if (isTooEarly) {
                    earlyZone.style.opacity = '1';
                    earlyZone.style.boxShadow = '0 0 15px #ff7732, 0 0 15px rgba(255, 119, 50, 0.2)';
                } else {
                    lateZone.style.opacity = '1';
                    lateZone.style.boxShadow = '0 0 15px #ff7732, 0 0 15px rgba(255, 119, 50, 0.2)';
                }
                timingMeter.style.transform = 'translateX(-50%)';
            } else {
                timingMeter.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(0, 0, 0, 0.5)';
                if (isTooEarly) {
                    earlyZone.style.opacity = '1';
                    earlyZone.style.boxShadow = '0 0 15px #ff3232, 0 0 15px rgba(255, 50, 50, 0.2)';
                } else {
                    lateZone.style.opacity = '1';
                    lateZone.style.boxShadow = '0 0 15px #ff3232, 0 0 15px rgba(255, 50, 50, 0.2)';
                }
                timingMeter.style.transform = 'translateX(-50%)';
            }

            // Freeze indicator with enhanced style
            const indicator = document.getElementById('timingIndicator');
            indicator.style.transition = 'none';
            indicator.style.boxShadow = `0 0 12px ${color}, 0 0 20px ${color}`;
            indicator.style.backgroundColor = color;

            // Hide after delay with smooth transition
            setTimeout(() => {
                timingMeterActive = false;
                indicator.style.opacity = '0';

                // Reset styles with smooth transition
                timingMeter.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(0, 0, 0, 0.5)';
                timingMeter.style.transform = 'translateX(-50%)';
                earlyZone.style.opacity = '0.7';
                okayEarlyZone.style.opacity = '0.7';
                perfectZone.style.opacity = '0.7';
                okayLateZone.style.opacity = '0.7';
                lateZone.style.opacity = '0.7';

                // Reset box-shadows
                earlyZone.style.boxShadow = '0 0 8px #ff3232';
                okayEarlyZone.style.boxShadow = '0 0 5px #ffcc00';
                perfectZone.style.boxShadow = '0 0 8px #32ff32';
                okayLateZone.style.boxShadow = '0 0 5px #ffcc00';
                lateZone.style.boxShadow = '0 0 8px #ff3232';

                setTimeout(() => {
                    resultText.style.opacity = '0';
                    resultText.style.transform = 'translateX(-50%) scale(0.9)';
                }, 1000);
            }, 500);
        }

        // Helper function to convert color to RGB values for shadow effect
        function getColorRGB(color) {
            if (color === '#32ff32') return '50, 255, 50';     // Green
            if (color === '#ffff32') return '255, 255, 50';    // Yellow
            if (color === '#ffcc32') return '255, 204, 50';    // Orange-yellow
            if (color === '#ff7732') return '255, 119, 50';    // Orange
            if (color === '#ff3232') return '255, 50, 50';     // Red
            if (color === 'gold') return '255, 215, 0';        // Gold (legacy)
            if (color === '#44cc44') return '68, 204, 68';     // Green (legacy)
            if (color === '#88cc44') return '136, 204, 68';    // Light green (legacy)
            if (color === '#cccc44') return '204, 204, 68';    // Yellow (legacy)
            if (color === '#cc4444') return '204, 68, 68';     // Red (legacy)
            return '255, 255, 255';
        }

        // Start the game
        init();
    </script>
</body>

</html>